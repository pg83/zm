#!/usr/bin/env python3

import os
import sys
import json
import yaml
import zlib
import time
import queue
import base64
import shutil
import atexit
import pickle
import marshal
import hashlib
import profile
import argparse
import platform
import functools
import threading
import subprocess
import collections
import multiprocessing


CACHE_V = '5'


if __name__ == '__main__':
    argp = argparse.ArgumentParser()

    argp.add_argument('target', nargs='?', default='.')

    argp.add_argument('-v', '--verbose', help='verbose mode', default=False, action='store_const', const=True)
    argp.add_argument('-c', '--clear', help='clear cache', default=False, action='store_const', const=True)
    argp.add_argument('-p', '--profile', help='run profiler', default=False, action='store_const', const=True)
    argp.add_argument('-G', '--dump-graph', help='dump graph', default=False, action='store_const', const=True)
    argp.add_argument('-j', '--threads', help='thread count', default=-1)
    argp.add_argument('-B', '--build-dir', help='build dir', default='')
    argp.add_argument('--flame-graph', help='dump flame graph', default=False, action='store_const', const=True)
    argp.add_argument('--host-platform', help='host platform', default='')
    argp.add_argument('--target-platform', help='target platform', default='')

    args = argp.parse_args(sys.argv[1:])


class PluginBase(object):
    def parse(self, data):
        return []

    def depends(self):
        return []


class EmptyPlugin(PluginBase):
    def ext(self):
        return ['']


class File2CPlugin(PluginBase):
    def ext(self):
        return ['file2c']

    def command(self, src, module):
        o = to_bd(strip_ext(src) + '.h')
        tool = '$(B)/tp/tools/file2c/file2c'

        return [
            {
                'in': [src],
                'out': [o],
                'cmd': [
                    ['/bin/sh', '-c', tool + ' < ' + src + ' > ' + o],
                ],
                'use': [tool],
            },
        ]


class Ragel6Plugin(PluginBase):
    def ext(self):
        return ['rl', 'rl6']

    def command(self, src, module):
        o = to_bd(strip_ext(src))
        tool = '$(B)/tp/tools/ragel/ragel'

        if not fext(o):
            o = o + '.cpp'

        return [
            {
                'in': [src],
                'out': [o],
                'cmd': [
                    [tool, '-G1', src, '-o', o],
                ],
                'use': [tool],
                'out_inc': module.parse_includes_md5(src, fext(o))
            },
        ]

    def parse(self, data):
        for l in data.splitlines():
            l = l.strip()

            if not l.startswith('include'):
                continue

            if res := get_substr(l, '"', '"'):
                yield res
            else:
                raise Exception('unparsed include ' + l)


class ProtoBufPlugin(PluginBase):
    def ext(self):
        return ['proto']

    def command(self, src, module):
        pb = to_bd(strip_ext(src))

        pbc = pb + '.pb.cc'
        pbh = pb + '.pb.h'

        f1 = '$(S)/tp/libs/protobuf/src/google/protobuf/any.pb.cc'
        f2 = '$(S)/tp/libs/protobuf/src/google/protobuf/any.pb.h'

        tool = '$(B)/tp/tools/protoc/protoc'

        return [
            {
                'in': [src],
                'out': [pbc, pbh],
                'cmd': [
                    [tool, '-I=.', '-I=$(S)', '-I=$(B)', '--cpp_out=$(B)', src[5:]],
                ],
                'use': [tool],
                'out_inc': module.parse_includes_md5(f1, 'cpp') + module.parse_includes_md5(f2, 'cpp'),
                'cwd': '$(S)',
            },
        ]

    def parse(self, data):
        for l in data.splitlines():
            l = l.strip()

            if not l.startswith('import'):
                continue

            if res := get_substr(l, '"', '"'):
                yield res
            else:
                raise Exception('unparsed include ' + l)

    def depends(self):
        return ['tp/libs/protobuf']


class CppPlugin(PluginBase):
    def ext(self):
        return ['C', 'cpp', 'cc', 'cxx', 'c++']

    def command(self, src, module):
        o = to_bd(src + '.o')

        return [
            {
                'in': [src],
                'out': [o],
                'cmd': module.compiler.cxx_compile_command(src, o, list(module.iter_inc_dirs()) + ['$(B)'], module.cxx_flags),
            },
        ]

    def parse(self, data):
        return parse_cpp_includes(data)


class CPlugin(PluginBase):
    def ext(self):
        return ['c', 'S', 's']

    def command(self, src, module):
        o = to_bd(src + '.o')

        return [
            {
                'in': [src],
                'out': [o],
                'cmd': module.compiler.c_compile_command(src, o, list(module.iter_inc_dirs()) + ['$(B)'], module.c_flags),
            },
        ]

    def parse(self, data):
        return parse_cpp_includes(data)


class YasmPlugin(PluginBase):
    def ext(self):
        return ['asm', 'yasm']

    def command(self, src, module):
        o = to_bd(strip_ext(src) + '.o')
        t = module.platform

        def iter_flags():
            for f in t.defines:
                yield '-D'
                yield f

        tool = '$(B)/tp/tools/yasm/yasm'

        return [
            {
                'in': [src],
                'out': [o],
                'cmd': [
                    [tool, '-f', t.complete_exe_format] + list(iter_flags()) + ['-D', '_YASM_', '-I', '$(S)', '-o', o, src],
                ],
                'use': [tool],
            },
        ]

    def parse(self, data):
        for l in data.splitlines():
            l = l.strip()

            if not l:
                continue

            if l[0] != '%':
                continue

            ll = l.replace(' ', '').replace('\t', '')

            if not ll.startswith('%include'):
                continue

            if res := get_substr(ll, '"', '"'):
                yield res
            else:
                raise Exception('unparsed include ' + l)


def singleton(f):
    @functools.wraps(f)
    def wrapper():
        try:
            wrapper.__res__
        except AttributeError:
            wrapper.__res__ = f()

        return wrapper.__res__

    return wrapper


## colors


ATTRIBUTES = dict(
    list(zip(
        [
            'bold',
            'dark',
            '',
            'underline',
            'blink',
            '',
            'reverse',
            'concealed'
        ], list(range(1, 9)))))

del ATTRIBUTES['']

ATTRIBUTES['light'] = ATTRIBUTES['bold']

HIGHLIGHTS = dict(
    list(zip([
        'on_grey',
        'on_red',
        'on_green',
        'on_yellow',
        'on_blue',
        'on_magenta',
        'on_cyan',
        'on_white'
    ], list(range(40, 48)))))

COLORS = dict(
    list(zip([
        'steel',
        'red',
        'green',
        'yellow',
        'blue',
        'magenta',
        'cyan',
        'white',
    ], list(range(30, 38)))))

COLORS['reset'] = 0


def get_code(code):
    return "\033[{}m".format(code)


def get_color_0(color, on_color):
    res = ''

    if color is not None:
        res += get_code(COLORS[color])

    if on_color is not None:
        res += get_code(HIGHLIGHTS[on_color])

    return res


def color_key(color, on_color):
    return str(color) + '-' + str(on_color)


def iter_all_colors():
    for c in list(COLORS.keys()) + [None]:
        for o in list(HIGHLIGHTS.keys()) + [None]:
            yield color_key(c, o), get_color_0(c, o)


CC = dict(iter_all_colors())


def get_color_ext(color, on_color=None, attrs=[]):
    res = CC[color_key(color, on_color)]

    for attr in attrs:
        res += get_code(ATTRIBUTES[attr])

    return res


def iter_synonyms():
    for c in COLORS:
        if c == 'reset':
            continue

        yield c[0], c
        yield c, c


def iter_combo():
    attrs = [[], ['bold'], ['dark'], ['bold', 'dark']]

    for s, c in iter_synonyms():
        for a in attrs:
            if len(s) == 1:
                aa = [x[0] for x in a]
            else:
                aa = a

            name = ''.join(aa + [s])
            b = [x for x in a]

            yield name, c, b
            yield '{' + name + '}', c, b


def iter_full_table():
    for n, c, a in iter_combo():
        yield n, get_color_ext(c, on_color=None, attrs=a)

    for r in ('', 'rst', 'reset'):
        yield r, get_code(0)
        yield '{' + r + '}', get_code(0)


COLOR_TABLE = dict(iter_full_table())


def get_color(n):
    return COLOR_TABLE[n]


def colorize(text, color):
    return get_color(color) + text + get_color('')


class Display(object):
    def __init__(self):
        self._mm = set()
        self._ml = threading.Lock()

    def msg(self, l, c, msg):
        m = ''

        if args.verbose:
            m += colorize('(' + str(struct_hash(threading.get_ident()))[:4] + ')', 'bb')
            m += ' '

        m += colorize('[' + l + ']', c)
        m += ' '

        m += msg.replace('$(S)', colorize('$(S)', 'bg')).replace('$(B)', colorize('$(B)', 'by'))

        with self._ml:
            if m in self._mm:
                return

            self._mm.add(m)

            print(m, file=sys.stderr)


@singleton
def display():
    return Display()


def msg(*args, **kwargs):
    display().msg(*args, **kwargs)


## end color


def preprocess(data, flags):
    def iter_lines():
        all_flags = collections.defaultdict(bool)

        for x in flags:
            all_flags[x] = True

        skip = False

        for l in data.split('\n'):
            if '#endif' in l:
                skip = False
            elif '#if' in l:
                skip = not eval(l[3:].strip(), {}, all_flags)
            elif skip:
                if args.verbose:
                    msg('S', 'by', l)
            else:
                yield l

    return '\n'.join(iter_lines()).strip()


def filter_cmd_out(o):
    def iter_lines():
        for l in o.split('\n'):
            if 'creating archive' in l:
                continue

            if 'ar: creating' in l:
                continue

            if 'warning: creating' in l:
                continue

            if 'has no symbols' in l:
                continue

            yield l

    return '\n'.join(iter_lines()).strip()


def run_cmd(cmd, cwd, tmp_dir):
    env = {'TMPDIR': tmp_dir}
    p = subprocess.Popen(cmd, shell=False, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=cwd)
    out, err = p.communicate()
    code = p.wait()
    out = filter_cmd_out(out.decode('utf-8'))

    if code:
        raise Exception((' '.join(cmd) + ' with exit code ' + str(code) + '\n' + out).strip())

    return out


def join_path(a, b):
    if not a:
        return b

    if not b:
        return a

    return a + '/' + b


def iter_uniq_list_base(l, key):
    v = set()

    for x in l:
        k = key(x)

        if k not in v:
            v.add(k)

            yield x


def uniq_list_base(l, key):
    return list(iter_uniq_list_base(l, key))


def iter_uniq_list(l):
    return iter_uniq_list_base(l, lambda x: x)


def uniq_list(l):
    return list(iter_uniq_list(l))


class AtExit(object):
    def __init__(self):
        self._f = []

        atexit.register(self.at_exit)

    def register(self, f):
        self._f.append(f)

    def at_exit(self):
        for f in self._f:
            f()


@singleton
def at_exit_obj():
    return AtExit()


def at_exit(f):
    at_exit_obj().register(f)

    return f


def prof(meth):
    class Wrapper(object):
        def __init__(self):
            self.t = 0
            self.c = 0

            at_exit(self.print)

        def print(self):
            msg('P', 'by', meth.__name__ + ' -> time = ' + str(self.t) + ', count = ' + str(self.c))

        def inc(self, t):
            self.t += t
            self.c += 1

    w = Wrapper()

    @functools.wraps(meth)
    def wrapper(*args, **kwargs):
        t1 = time.time()

        try:
            return meth(*args, **kwargs)
        finally:
            w.inc(time.time() - t1)

    return wrapper


def cached_method(meth):
    @functools.wraps(meth)
    def wrapper(self, *args, **kwargs):
        try:
            self.__cache__
        except AttributeError:
            self.__cache__ = {}

        d = self.__cache__

        if args or kwargs:
            k = struct_hash([args, kwargs, meth.__name__])
        else:
            k = meth.__name__

        if k not in d:
            d[k] = None
            d[k] = meth(self, *args, **kwargs)

        return d[k]

    return wrapper


@singleton
def find_root():
    res = os.path.dirname(os.path.dirname(os.path.normpath(os.path.abspath(__file__))))

    msg('R', 'by', res)

    return res


def get_target(t):
    return os.path.normpath(os.path.abspath(os.path.join(os.getcwd(), t)))


def strip_prefix(s, p):
    assert s.startswith(p), 'out of source root'

    return s[len(p) + 1:]


def get_substr(s, b, e):
    p = s.find(b)

    if p < 0:
        return None

    s = s[p + len(b):]
    p = s.find(e)

    assert p > 0

    s = s[:p]

    return b + s + e


def parse_cpp_includes(data):
    for l in data.splitlines():
        l = l.strip()

        if not l:
            continue

        if l[0] != '#':
            continue

        ll = l.replace(' ', '').replace('\t', '')

        if not ll.startswith('#include'):
            continue

        ll = ll.replace('_LIBCPP_EXTERNAL_THREADING', '<__external_threading>')
        ll = ll.replace('OPENSSL_UNISTD', '<unistd.h>')

        if res := get_substr(ll, '<', '>'):
            yield res
        elif res := get_substr(ll, '"', '"'):
            yield res
        elif res := get_substr(ll, '(', ')'):
            yield res
        else:
            raise Exception('unparsed include ' + l)


class Plugins(object):
    def __init__(self):
        self._by_ext = {}

        for k, v in globals().items():
            if k.endswith('Plugin'):
                self.register(v())

    def register(self, p):
        if args.verbose:
            msg('R', 'br', 'register ' + p.__class__.__name__)

        for e in p.ext():
            self._by_ext[e] = p

    def find_ext(self, e):
        return self._by_ext[e]

    def find_path(self, p):
        return self.find_ext(fext(p))


@singleton
def plugins():
    return Plugins()


def to_bd(p):
    return p.replace('$(S)', '$(B)', 1)


def to_sd(p):
    return p.replace('$(B)', '$(S)', 1)


def fext(p):
    a, b, c = p.rpartition('.')

    if b:
        return c

    return ''


def strip_ext(p):
    a, b, c = p.rpartition('.')

    if b:
        return a

    return p


def node_key(n):
    return n['out'][0]


def uniq_nodes(g):
    return uniq_list_base(g, node_key)


def add_platform(g, p):
    for n in g:
        n['platform'] = p

    return g


class Module(object):
    def __init__(self, data, parser, prefix, platform):
        self._d = data
        self._p = prefix
        self._parser = parser
        self._c = {}
        self._pl = platform

    @property
    def platform(self):
        return self._pl

    @property
    def name(self):
        return self._d.get('name', '') or os.path.basename(self.prefix.replace('/src', ''))

    def extra_depends(self):
        return []

    @property
    @cached_method
    def depends(self):
        def iter_deps():
            yield from self._d.get('depends', [])
            yield from self.extra_depends()

            for s in self.srcs:
                yield from plugins().find_path(s).depends()

        return uniq_list(iter_deps())

    @property
    @cached_method
    def inc_dirs(self):
        return uniq_list(self.global_inc_dirs + self._d.get('inc_dirs', []))

    @property
    @cached_method
    def global_inc_dirs(self):
        def iter_dirs():
            yield from self._d.get('global_inc_dirs', [])

            for sm in self.iter_sub_modules(self.depends):
                yield from sm.global_inc_dirs

        return uniq_list(iter_dirs())

    @property
    def c_flags(self):
        return self._d.get('c_flags', []) + self._d.get('c_only_flags', [])

    @property
    def cxx_flags(self):
        return self._d.get('c_flags', []) + self._d.get('cxx_flags', [])

    @property
    @cached_method
    def ld_flags(self):
        def iter_flags():
            yield from self._d.get('ld_flags', [])

            for sm in self.iter_sub_modules(self.depends):
                yield from sm.ld_flags

        return uniq_list(iter_flags())

    @property
    def parser(self):
        return self._parser

    @property
    def prefix(self):
        return self._p

    @property
    def srcs(self):
        return [('$(S)/' + self.prefix + '/' + x) for x in self._d.get('srcs', [])]

    @property
    def join_srcs(self):
        return [('$(S)/' + self.prefix + '/' + x) for x in self._d.get('join_srcs', [])]

    @property
    def compiler(self):
        return self.platform.compiler

    def src_path_0(self, p):
        rp = self.parser.replace_path(p)

        if './' in p:
            return os.path.normpath(rp)

        return rp

    def src_path(self, p):
        if p not in self._c:
            self._c[p] = self.src_path_0(p)

        return self._c[p]

    def parse_includes(self, pp, ext):
        v = set()
        dp = os.path.dirname(pp)
        ip = self.parser.inc_parser

        def do(p):
            if p in v:
                return

            v.add(p)

            p = self.find_location(p, dp)

            yield p

            if from_sd(p):
                for i in ip.parse_includes(self.src_path(p), ext):
                    yield from do('$(S)/' + i[1:-1])

        return do(pp)

    @cached_method
    def exists(self, p):
        return self.parser.loader.exists(p)

    @cached_method
    def find_location(self, p, w):
        def it():
            yield w
            yield from self.iter_inc_dirs()

        for x in iter_uniq_list(it()):
            pp = p.replace('$(S)', x)

            if self.exists(self.src_path(pp)):
                return pp

        return to_bd(p)

    def iter_inc_dirs(self):
        yield '$(S)'

        for x in self.inc_dirs:
            yield '$(S)/' + x

    def parse_includes_md5(self, p, ext):
        def it():
            md5 = self.parser.md5_calcer

            for i in self.parse_includes(p, ext):
                if from_bd(i):
                    yield {
                        'path': i,
                    }
                else:
                    yield {
                        'path': i,
                        'md5': md5.get_md5(self.src_path(i)),
                    }

        return list(it())

    def build_one_command(self, src):
        try:
            return plugins().find_path(src).command(src, self)
        except KeyError:
            return []

    def build_command(self, src):
        v = set()

        def do(s):
            if s in v:
                return

            v.add(s)

            for c in self.build_one_command(s):
                for o in c['out']:
                    yield from do(o)

                yield c

        return list(do(src))

    def resource_command(self, data):
        def iter_res():
            for l in data:
                f, k = l.split(' ')

                if k[0] != '/':
                    k = '/' + k

                s = '$(S)/' + self.prefix + '/' + f

                yield s, k, s + ' ' + k

        srcs = []
        lines = []

        for f, k, l in iter_res():
            srcs.append(f)
            lines.append(l)

        out = '$(B)/' + self.prefix + '/resource.global.' + str(struct_hash(lines)) + '.cpp'
        tool = '$(B)/libs/resource/compiler/compiler'

        return {
            'in': srcs,
            'out': [out],
            'cmd': [
                ['/bin/sh', '-c', tool + ' ' + ' '.join(lines) + ' > ' + out],
            ],
            'use': [tool],
            'out_inc': self.parse_includes_md5('$(S)/libs/resource/resource.h', 'cpp'),
        }

    def join_srcs_command(self, srcs):
        o = '$(B)/' + self.prefix + '/' + str(struct_hash(srcs)) + '.' + fext(srcs[0])

        def iter_cmds():
            for l in srcs:
                yield ['/bin/sh', '-c', 'echo "#include \\"' + l + '\\"" >> ' + o]

        return {
            'in': srcs,
            'out': [o],
            'cmd': list(iter_cmds()),
        }

    def link_command(self, srcs, out):
        o = '$(B)/' + self.prefix + '/' + out

        return {
            'in': srcs,
            'out': [o],
            'cmd': self.compiler.link_command(srcs, o, self.ld_flags),
            'main': True,
        }

    def fatobj_command(self, srcs, out):
        o = '$(B)/' + self.prefix + '/' + out

        return {
            'in': srcs,
            'out': [o],
            'cmd': self.compiler.fatobj_command(srcs, o),
            'main': True,
        }

    def ar_command(self, srcs, out):
        o = '$(B)/' + self.prefix + '/' + out

        return {
            'in': srcs,
            'out': [o],
            'cmd': self.compiler.ar_command(srcs, o),
            'main': True,
        }

    def iter_commands(self):
        if js := self.join_srcs:
            yield self.join_srcs_command(js)

        if data := self._d.get('resource', []):
            yield self.resource_command(data)

    def iter_simple_commands_0(self):
        for s in self.srcs:
            yield from self.build_command(s)

        for cmd in self.iter_commands():
            yield cmd

            for o in cmd['out']:
                yield from self.build_command(o)

    def iter_simple_commands(self):
        def iter_inc(c):
            for i in c['in']:
                yield from self.parse_includes_md5(i, fext(i))

        for c in self.iter_simple_commands_0():
            c['inc'] = [list(iter_inc(c))]

            yield c

    def iter_sub_modules(self, deps):
        for d in iter_uniq_list(deps):
            yield self.parser.parse_module(d, self.platform)

    def iter_sub_commands(self, deps):
        for d in self.iter_sub_modules(deps):
            yield from d.commands()

    @cached_method
    def calc_simple_commands(self):
        return list(self.iter_simple_commands())

    @cached_method
    def calc_depend_commands(self):
        return uniq_nodes(self.iter_sub_commands(self.depends))

    @cached_method
    def calc_commands(self):
        cc = self.calc_simple_commands()
        dc = self.calc_depend_commands()

        def iter_ss():
            for l in cc:
                for o in l['out']:
                    if o.endswith('.o'):
                        yield o

        ss = list(iter_ss())

        return cc, ss, dc

    def full_commands(self):
        cc = self.commands()

        def iter_programs():
            for l in cc:
                for x in l.get('use', []):
                    yield os.path.dirname(x)[5:]

        programs = uniq_list(iter_programs())

        def iter_nodes():
            yield from self.iter_sub_commands(programs)
            yield from cc

        return add_platform(build_uids(output_includes(uniq_nodes(iter_nodes()))), self.platform.descr)

    def calc_main(self, g):
        return [g[-1]['uid']]


def find_path(p):
    for x in os.environ['PATH'].split(':'):
        pp = os.path.join(x, p)

        if os.path.exists(pp):
            return pp

    raise Exception('can not find ' + p)


class SystemCompiler(object):
    def __init__(self, target):
        self._t = target

    @property
    def name(self):
        return 'clang'

    def compile_command(self, cxx, src, out, inc, flags):
        def it():
            yield from cxx

            yield '--target=' + self._t.descr

            yield '-fcolor-diagnostics'

            yield '-msse2'
            yield '-msse3'
            yield '-mssse3'
            yield '-msse4.1'
            yield '-msse4.2'
            yield '-mpopcnt'
            yield '-mcx16'

            yield from self.extra_c_flags()
            yield from flags

            for x in inc:
                yield '-I' + x

            yield '-c'
            yield '-o'
            yield out
            yield src

        return [list(it())]

    def find_tool(self, t):
        return os.path.join(self._d, t)

    def c_compile_command(self, src, out, inc, flags):
        return self.compile_command(['clang'], src, out, inc, flags)

    def cxx_compile_command(self, src, out, inc, flags):
        return self.compile_command(['clang++'], src, out, inc, ['-std=c++17', '-nostdinc++'] + flags)

    def link_command(self, srcs, out, flags):
        def iter_flags():
            yield 'clang++'
            yield '--target=' + self._t.descr
            yield '-fcolor-diagnostics'
            yield '-nostdlib++'
            yield from self.extra_ld_flags()
            yield from flags
            yield '-o'
            yield out
            yield from self.fix_srcs(srcs)

        return [list(iter_flags())]

    def ar_command(self, srcs, out):
        return [
            ['llvm-ar', 'q', out] + srcs,
            ['llvm-ranlib', out],
        ]

    def fatobj_command(self, srcs, out):
        if len(srcs) > 1:
            return [[self.linker, '-r', '-o', out] + srcs]

        return [['cp', srcs[0], out]]

    def fix_srcs(self, srcs):
        for s in srcs:
            if s.endswith('.o'):
                yield s

        yield '-Wl,--start-group'

        for s in srcs:
            if not s.endswith('.o'):
                yield s

        yield '-Wl,--end-group'

    @property
    def linker(self):
        return 'ld.lld'

    def extra_ld_flags(self):
        yield '-fuse-ld=lld'

    def extra_c_flags(self):
        return []


class DarwinCompiler(SystemCompiler):
    def fix_srcs(self, srcs):
        return srcs

    @property
    def linker(self):
        return 'ld64.lld'

    def extra_ld_flags(self):
        yield '-L/Library/Developer/CommandLineTools/SDKs/MacOSX11.0.sdk/usr/lib'

    def extra_c_flags(self):
        yield '-isystem/Library/Developer/CommandLineTools/SDKs/MacOSX11.0.sdk/usr/include'


class Program(Module):
    @property
    def allocator(self):
        return self._d.get('allocator', 'mim')

    @cached_method
    def commands(self):
        cc, ss, dc = self.calc_commands()

        def iter_ls():
            for l in dc:
                for o in l['out']:
                    if o.endswith('.a'):
                        yield o
                    elif o.endswith('.global.o'):
                        yield o

        ls = list(iter_ls())

        return cc + dc + [self.link_command(ss + ls, self.name)]

    def more_deps(self):
        return []

    def iter_extra_deps(self):
        yield 'tp/libs/cxx'

        if self.name in ['yasm']:
            yield 'tp/libs/strings'
        else:
            yield 'tp/libs/asmlib'

        alloc = {
            'mim': 'tp/libs/mimalloc',
            'lf': 'tp/libs/lfalloc',
        }

        yield alloc[self.allocator]
        yield from self.more_deps()

    def extra_depends(self):
        return list(self.iter_extra_deps())


class GTest(Program):
    def more_deps(self):
        yield 'tp/libs/gtest'


class BenchMark(Program):
    def more_deps(self):
        yield 'tp/libs/benchmark'


class Library(Module):
    exclude = frozenset([
        'tp/libs/cxx',
        'tp/libs/cxx/include',
        'tp/libs/cxx/src',
        'tp/libs/cxxrt',
        'tp/libs/unwind',
        'tp/libs/unwind/src',
        'tp/libs/demangle',
        'tp/libs/musl',
        'tp/libs/muslinc',
        'tp/libs/kernel',
    ])

    @cached_method
    def commands(self):
        cc, ss, dc = self.calc_commands()

        if ss:
            return cc + dc + [self.ar_command(ss, ('lib' + self.name + '.a').replace('liblib', 'lib'))]

        return dc

    def extra_depends(self):
        if self.prefix not in self.exclude:
            return ['tp/libs/cxx']

        return []

    def calc_main(self, g):
        _, ss, _ = self.calc_commands()

        if ss:
            return [g[-1]['uid']]

        return []


class FatObj(Module):
    @cached_method
    def commands(self):
        cc, ss, dc = self.calc_commands()

        return cc + dc + [self.fatobj_command(ss, self.name + '.global.o')]

    def extra_depends(self):
        return ['tp/libs/cxx']


class Recurse(Module):
    @property
    def recurse(self):
        return self._d['recurse']

    @property
    def depends(self):
        def iter_deps():
            for d in self.recurse:
                yield join_path(self.prefix, d)

        return list(iter_deps())

    @cached_method
    def commands(self):
        return self.calc_depend_commands()

    def calc_main(self, g):
        def iter_main():
            for n in g:
                if n.get('main', False):
                    yield n['uid']

        return list(iter_main())


class Parser(object):
    BY_NAME = {
        'program': Program,
        'library': Library,
        'object': FatObj,
        'recurse': Recurse,
        'gtest': GTest,
        'benchmark': BenchMark,
    }

    def __init__(self, root, host_platform, target_platform, inc_parser):
        self._r = root
        self._i = inc_parser
        self._h = host_platform
        self._t = target_platform

        self._p = {
            self._h.descr: self._h,
            self._t.descr: self._t,
        }

    @property
    def md5_calcer(self):
        return self._i.md5_calcer

    @property
    def target_platform(self):
        return self._t

    @property
    def host_platform(self):
        return self._h

    @property
    def inc_parser(self):
        return self._i

    @property
    def loader(self):
        return self.inc_parser.loader

    @property
    def root(self):
        return self._r

    def replace_path(self, p):
        return p.replace('$(S)', self.root)

    def parse_module(self, target, platform):
        return self.parse_module_impl(target, platform.descr)

    @cached_method
    def parse_module_impl(self, target, platform):
        msg('T', 'bc', '{' + platform + '} ' + '$(S)/' + target)

        pt = self.platform_by_name(platform)

        with open(os.path.join(self.root, target, 'z.make'), 'r') as f:
            d = yaml.safe_load(preprocess(f.read(), pt.flags))

        if 'recurse' in d:
            return Recurse(d, self, target, pt)

        def error(*args):
            raise Exception('unsupported module ' + target)

        return self.BY_NAME.get(d['module'], error)(d, self, target, pt)

    def platform_by_name(self, name):
        return self._p[name]


def from_bd(i):
    return i[2] == 'B'


def from_sd(i):
    return i[2] == 'S'


def struct_hash(s):
    return zlib.crc32(marshal.dumps(s))


def flatten(l):
    for x in l:
        yield from x


def repl_uid(n, fr, to):
    def iter_deps():
        for d in n['deps']:
            if d == fr:
                yield to
            else:
                yield d

    n['deps'] = list(iter_deps())


def merge_tools(g, t):
    by_out_t = {}
    by_out_g = {}

    for n in t:
        for o in n['out']:
            by_out_t[o] = n

    for n in g:
        for o in n['out']:
            by_out_g[o] = n

    for n in g:
        if 'use' in n:
            for u in n['use']:
                ug = by_out_g[u]['uid']
                ut = by_out_t[u]['uid']

                if ug != ut:
                    repl_uid(n, ug, ut)

    return g + t


def output_includes(g):
    by_out = {}

    for n in g:
        if 'out_inc' in n:
            oi = n.pop('out_inc')

            for o in n['out']:
                by_out[o] = oi

    for n in g:
        for i in list(iter_node_in(n)):
            if i in by_out:
                n['inc'] = n.get('inc', []) + [by_out[i]]

    return g


def iter_node_in(n):
    def iter_in():
        for i in n['in']:
            if from_bd(i):
                yield i

        yield from n.get('use', [])

        for f in flatten(n.get('inc', [])):
            if 'md5' not in f:
                yield f['path']

    return iter_uniq_list(iter_in())


def strip_uids(g, used):
    v = set()
    by_uid = {}

    for n in g:
        by_uid[n['uid']] = n

    def visit(uid):
        if uid in v:
            return

        v.add(uid)

        n = by_uid[uid]

        for d in n['deps']:
            yield from visit(d)

        yield n

    def iter_nodes():
        for uid in used:
            yield from visit(uid)

    return list(iter_nodes())


def build_uids(g):
    by_out = {}

    for n in g:
        for o in n['out']:
            by_out[o] = n

    def uid(n):
        if 'uid' not in n:
            deps = []

            for i in iter_node_in(n):
                if i in by_out:
                    deps.append(uid(by_out[i]))
                else:
                    if args.verbose:
                        msg('U', 'br', i)

            n['deps'] = deps
            n['uid'] = struct_hash(n)

        return n['uid']

    for x in g:
        uid(x)

    return g


def prepare_dir(ro):
    try:
        os.makedirs(os.path.dirname(ro))
    except OSError:
        pass


def simple_engine(it, key=lambda x: x):
    by_dep = collections.defaultdict(set)
    by_rdep = collections.defaultdict(set)

    for k, v in it:
        by_dep[k].add(v)
        by_rdep[v].add(k)

    deps = set(by_dep.keys())
    rdeps = set(by_rdep.keys())
    ready = rdeps - deps

    def iter_ready():
        while ready:
            tmp = list(sorted(ready, key=key))

            ready.clear()

            for t in tmp:
                if t is not None:
                    yield t
                else:
                    cb(None)

    def cb(item):
        for k in by_rdep[item]:
            el = by_dep[k]

            el.remove(item)

            if not el:
                by_dep.pop(k)
                ready.add(k)

    return iter_ready, cb


def make_func(d):
    def func():
        return d

    return func


def make_err(n, e):
    def func():
        raise Exception('while build ' + ' '.join(n['out']) + ': ' + str(e))

    return func


def hard_link(f, t):
    prepare_dir(t)
    os.link(f, t)


class Builder(object):
    def __init__(self, g, main_uids, parser, build_dir):
        self._g = g
        self._m = main_uids
        self._p = parser
        self._bd = build_dir
        self._bu = {}

        for n in self._g:
            self._bu[n['uid']] = n

    def replace_path(self, p, n, w):
        uid = (n['uid']).to_bytes(4, 'little').hex()
        bp = p.replace('$(B)', self._bd + '/$(W)/' + uid[:2] + '/' + uid[2:]).replace('$(W)', w)

        return self._p.replace_path(bp)

    def visit(self):
        r, w = self.engine()

        while tmp := list(r()):
            for i in tmp:
                yield self._bu[i]
                w(i)

    def build(self):
        for n in self.visit():
            self.build_command(n)

    def iter_deps(self):
        for n in self._g:
            for d in n['deps']:
                yield n['uid'], d

    def engine(self):
        def sort_key(x):
            return ' '.join(self._bu[x]['out'])

        return simple_engine(self.iter_deps(), key=sort_key)

    def build_parallel(self, th):
        r, w = self.engine()

        qi = queue.SimpleQueue()
        qo = queue.SimpleQueue()

        def run_thr():
            while True:
                d = qi.get()
                n = self._bu[d]

                try:
                    self.build_command(n)
                    qo.put(make_func(d))
                except Exception as e:
                    qo.put(make_err(n, e))

        for i in range(0, th):
            t = threading.Thread(target=run_thr)
            t.daemon = True
            t.start()

        v = set()

        while True:
            for i in r():
                qi.put(i)
                v.add(i)

            if not v:
                return

            res = qo.get()()

            w(res)
            v.remove(res)

    def build_command(self, n):
        self.build_command_1(n)

        if n['uid'] in self._m:
            for o in n['out']:
                f = self.replace_path(o, n, 'c')
                s = to_sd(o if fext(o) else (o + '.exe'))
                t = self._p.replace_path(s)

                if args.verbose:
                    msg('S', 'bb', '{' + n['platform'] + '} ' + s)

                try:
                    os.unlink(t)
                except Exception:
                    pass

                os.symlink(f, t)

    def build_command_1(self, n):
        while True:
            try:
                return self.build_command_0(n)
            except Exception as e:
                if 'I/O error' in str(e):
                    msg('B', 'br', 'retry error ' + str(e))
                else:
                    raise e

    def build_command_0(self, n):
        where_c = self.replace_path('$(B)', n, 'c')

        if os.path.exists(where_c):
            return

        where_t = self.replace_path('$(B)', n, 't')
        where_p = where_t + '.tmp'

        shutil.rmtree(where_t, ignore_errors=True)
        shutil.rmtree(where_p, ignore_errors=True)

        for o in n['out']:
            prepare_dir(self.replace_path(o, n, 't'))

        def sl(s, d, *args, **kwargs):
            os.symlink(s, d)

        for d in n['deps']:
            dn = self._bu[d]

            shutil.copytree(self.replace_path('$(B)', dn, 'c'), where_t, copy_function=sl, dirs_exist_ok=True)

        m = []

        def app_msg(ms):
            if ms:
                m.append(ms)

        app_msg('{' + n['platform'] + '} ' + ' '.join(n['out']))

        for c in n['cmd']:
            cmd = [self.replace_path(x, n, 't') for x in c]
            cwd = self.replace_path(n.get('cwd', '/'), n, 't')

            if args.verbose:
                app_msg(colorize('CWD=' + cwd + ' ' + ' '.join(cmd), 'dw'))

            app_msg(run_cmd(cmd, cwd, self._bd))

        for o in n['out']:
            f = os.path.join(where_t, o[5:])
            t = os.path.join(where_p, o[5:])

            hard_link(f, t)

        shutil.rmtree(where_t)
        shutil.move(where_p, where_c)

        msg('B', 'g', '\n'.join(m).strip())


class Target(object):
    def __init__(self, os, arch):
        self.os = os
        self.arch = arch

    @property
    def descr(self):
        return self.os + '-' + self.arch

    @property
    @cached_method
    def bits(self):
        if 'ARCH_X86_64' in self.flags:
            return 64

        if 'ARCH_AARCH64' in self.flags:
            return 64

        return 32

    @property
    @cached_method
    def is_unix(self):
        return self.os in ['darwin', 'linux', 'freebsd']

    @property
    @cached_method
    def flags(self):
        def iter_flags_0():
            yield 'os_' + self.os
            yield 'arch_' + self.arch

            if self.is_unix:
                yield 'os_unix'

            if self.os == 'linux':
                yield 'musl'

        def iter_flags_1():
            for f in iter_flags_0():
                yield f.upper()

        return list(iter_flags_1())

    @property
    @cached_method
    def defines(self):
        def iter_defines_0():
            yield self.os
            yield self.arch

            if self.is_unix:
                yield 'unix'

        def iter_defines_1():
            for f in iter_defines_0():
                yield f.upper()
                yield '_' + f + '_'

        return list(iter_defines_1())

    @property
    @cached_method
    def exe_format(self):
        if 'OS_DARWIN' in self.flags:
            return 'macho'

        return 'elf'

    @property
    @cached_method
    def complete_exe_format(self):
        return self.exe_format + str(self.bits)

    @property
    @cached_method
    def compiler(self):
        if 'OS_DARWIN' in self.flags:
            return DarwinCompiler(self)

        return SystemCompiler(self)


@singleton
def run_target():
    return Target(platform.system().lower(), platform.machine().lower())


def parse_platform(p):
    a, b = p.split('-')

    return Target(a, b)


class FileLoader(object):
    @cached_method
    def get_data(self, p):
        msg('L', 'by', p)

        with open(p, 'r') as f:
            return f.read()

    @cached_method
    def get_mtime(self, p):
        return os.stat(p).st_mtime

    @cached_method
    def exists(self, p):
        return os.path.basename(p) in self.list_dir(os.path.dirname(p))

    @cached_method
    def list_dir(self, d):
        try:
            return frozenset(os.listdir(d))
        except FileNotFoundError:
            return []


class MD5Calcer(object):
    LOADER = FileLoader()

    def get_md5(self, p):
        return self.calc_md5(p, self.loader.get_mtime(p))

    @cached_method
    def calc_md5(self, p, mt):
        return struct_hash(self.loader.get_data(p))

    @property
    def loader(self):
        return self.LOADER


class IncParser(object):
    def __init__(self, md5_calcer):
        self._m = md5_calcer

    def parse_includes(self, p, ext):
        subst = {
            'h': 'cpp',
            'H': 'cpp',
            'hxx': 'cpp',
            'hpp': 'cpp',
            'hh': 'cpp',
        }

        return self.parse_includes_0(p, self.md5_calcer.get_md5(p), subst.get(ext, ext))

    @cached_method
    def parse_includes_0(self, p, md5, ext):
        msg('P', 'bm', p)

        return list(plugins().find_ext(ext).parse(self.loader.get_data(p)))

    @property
    def loader(self):
        return self.md5_calcer.loader

    @property
    def md5_calcer(self):
        return self._m


def find_main_uids(g):
    au = [x['uid'] for x in g]
    uu = sum([x['deps'] for x in g], [])

    return sorted(frozenset(au) - frozenset(uu))


def main():
    build_dir = args.build_dir

    if not build_dir:
        build_dir = os.path.join(os.path.expanduser('~'), '.zbuild')

    if args.clear:
        shutil.rmtree(build_dir, ignore_errors=True)

    try:
        os.makedirs(build_dir)
    except OSError:
        pass

    if args.host_platform:
        host_platform = parse_platform(args.host_platform)
    else:
        host_platform = run_target()

    if args.target_platform:
        target_platform = parse_platform(args.target_platform)
    else:
        target_platform = host_platform

    cache = os.path.join(build_dir, 'cache.' + CACHE_V + '.' + host_platform.descr + '.' + target_platform.descr)

    try:
        with open(cache, 'rb') as f:
            inc = pickle.loads(f.read())
    except Exception:
        inc = IncParser(MD5Calcer())

    p = Parser(find_root(), host_platform, target_platform, inc)
    t = strip_prefix(get_target(args.target), p.root)

    mt = p.parse_module(t, p.target_platform)
    gt = mt.full_commands()
    mu = mt.calc_main(gt)

    mh = p.parse_module(t, p.host_platform)
    gh = mh.full_commands()

    g = strip_uids(merge_tools(gt, gh), mu)

    with open(cache, 'wb') as f:
        f.write(pickle.dumps(inc))

    if args.dump_graph:
        print(json.dumps(g, indent=4, sort_keys=True))

    bl = Builder(g, mu, p, build_dir)
    tc = int(args.threads)

    if tc < 0:
        tc = multiprocessing.cpu_count()

    if tc == 0:
        pass
    elif tc < 2:
        bl.build()
    else:
        bl.build_parallel(tc)

    msg('F', 'bg', 'complete')


if __name__ == '__main__':
    def run():
        if args.flame_graph:
            import flamegraph

            flamegraph.start_profile_thread(fd=open("./perf.log", "w"))

        if args.verbose:
            main()
        else:
            try:
                main()
            except Exception as e:
                msg('F', 'br', str(e))
            except KeyboardInterrupt:
                print('', file=sys.stderr)
                msg('F', 'br', 'sigint')

    if args.profile:
        profile.run('run()')
    else:
        run()
