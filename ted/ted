#!/usr/bin/env python3

import re
import io
import os
import sys
import tty
import queue
import signal
import cProfile
import fractions
import itertools
import threading
import functools
import contextlib

from collections import deque, defaultdict

import pygments.util as pu
import pygments.token as pt
import pygments.lexers as pl
import pygments.styles as ps


if 'graal' in os.path.basename(sys.executable):
    CHRT = dict((x, chr(x)) for x in range(0, 10000))

    def chr(c):
        return CHRT[c]


class PubSub:
    def __init__(self):
        self.s = defaultdict(list)

    def sub(self, t, f):
        self.s[t].append(f)

    def pub(self, t, *args, **kwargs):
        for f in self.s.get(t, []):
            f(*args, **kwargs)

    def msg(self, m):
        self.pub('message', m)


def esc(d):
    return chr(27) + d


def csi(*args):
    res = '[' + str(args[0])

    for a in args[1:]:
        res += ';'
        res += str(a)

    return esc(res)


def move(x, y):
    return csi(y + 1, x + 1) + 'H'


def retval(v):
    def func():
        return v

    return func


class SigWinch(Exception):
    pass


class Channel:
    def __init__(self):
        self.b = deque()
        self.i = io.FileIO(0, 'r')
        self.o = io.FileIO(1, 'w')
        self.q = queue.SimpleQueue()
        self.l = threading.Lock()

        #tty.setraw(self.i)
        os.system('stty raw')
        self.send(csi('?25l'))
        threading.Thread(target=self.runq, daemon=True).start()
        signal.signal(signal.SIGWINCH, self.sigwinch)

    def fini(self):
        os.system('tput reset')
        os.system('stty -raw')

    def sigwinch(self, *args):
        def err():
            if self.l.locked():
                return self.q.get()()

            raise SigWinch()

        self.q.put(err)

    def runq(self):
        try:
            while True:
                self.q.put(retval(self.i.read(1)))
        except Exception as e:
            def err():
                raise e

            self.q.put(err)

    def send(self, cmd):
        self.o.write(cmd.encode())

    def recv(self):
        return ord(self.q.get()())

    def next(self):
        try:
            return self.b.popleft()
        except IndexError:
            pass

        return self.recv()

    def read_seq(self, ch):
        while True:
            s = self.recv()

            if s == 27:
                return self.read_to(ch)[1:]

            self.b.append(s)

    def read_to(self, ch):
        res = []

        while True:
            s = self.recv()

            if s == ch:
                return res

            res.append(s)

    def resp(self, ch):
        return ''.join(chr(x) for x in self.read_seq(ord(ch)))

    def dims(self):
        with self.l:
            return self.dims_nointr()

    def dims_nointr(self):
        n = 16

        while True:
            x, y = self.try_dims(n)

            if x < n and y < n:
                return x, y

            n *= 2

    def try_dims(self, n):
        while True:
            self.send(move(n, n) + csi('6n'))

            y, x = self.resp('R').split(';')

            try:
                return int(x), int(y)
            except ValueError:
                pass


KMAP = [
    ('[A', 'up'),
    ('[B', 'down'),
    ('[C', 'right'),
    ('[D', 'left'),
    ('[F', 'end'),
    ('[H', 'home'),
    ('[1~', 'home'),
    ('[2~', 'insert'),
    ('[3~', 'delete'),
    ('[4~', 'end'),
    ('[5~', 'pageup'),
    ('[6~', 'pagedown'),
    ('[7~', 'home'),
    ('[8~', 'end'),
    ('OP', 'f1'),
    ('OQ', 'f2'),
    ('OR', 'f3'),
    ('OS', 'f4'),
    ('[P', 'f1'),
    ('[Q', 'f2'),
    ('[R', 'f3'),
    ('[S', 'f4'),
    ('[15~', 'f5'),
    ('[17~', 'f6'),
    ('[18~', 'f7'),
    ('[19~', 'f8'),
    ('[20~', 'f9'),
    ('[21~', 'f10'),
    ('[23~', 'f11'),
    ('[24~', 'f12'),
    ('[33~', 'f19'),
] + [(chr(x), f'alt-{chr(x)}') for x in range(ord('a'), ord('z'))]


def make_scan_trie():
    res = {}

    def substr(k):
        s = ''

        for c in k:
            s += c

            yield s

    for k, v in KMAP:
        for sk in substr(k):
            res[sk] = 'int'

        res[k] = v

    return res


class InputStream:
    TRIE = make_scan_trie()

    ASCII = dict(
        [(n + 1, f'ctrl-{chr(ch)}') for n, ch in enumerate(range(ord('a'), ord('z')))] + [
            (0,   'ctrl-space'),
            (8,   'bs'),
            (9,   'tab'),
            (10,  'lf'),
            (13,  'cr'),
            (127, 'bs'),
        ]
    )

    BROKEN_UNICODE = dict((bytes(k).decode(), v) for k, v in (
        ((226, 136, 145), 'alt-w'),
        ((197, 147),      'alt-q'),
        ((194, 174),      'alt-r'),
        ((226, 137, 136), 'alt-x'),
    ))

    def __init__(self, ch):
        self.ch = ch

    def next(self):
        key = self.ch.next()

        if key < 128:
            if key == 27:
                return self.scan_escape()

            val = self.ASCII.get(key)

            if val:
                return val

            if key >= 32:
                return chr(key)

            raise Exception(f'bad key {key}')

        res = self.scan_utf8(key)

        return self.BROKEN_UNICODE.get(res, res)

    def scan_utf8(self, key):
        runes = [key]

        for i in range(0, 4):
            runes.append(self.ch.next())

            try:
                return bytes(runes).decode()
            except UnicodeError:
                pass

    def scan_escape(self):
        p = ''

        while True:
            p += chr(self.ch.next())

            v = self.TRIE.get(p)

            if v:
                if v != 'int':
                    return v
            else:
                raise Exception(f'unknown escape sequence {p}')


class Color24:
    __slots__ = 't'

    def __init__(self, r, g, b):
        self.t = (r, g, b)

    def bg(self):
        return csi(48, 2, *self.t) + 'm'

    def fg(self):
        return csi(38, 2, *self.t) + 'm'


def bg8(n):
    return csi(48, 5, n) + 'm'


def fg8(n):
    return csi(38, 5, n) + 'm'


TBL8BG = [bg8(n) for n in range(0, 256)]
TBL8FG = [fg8(n) for n in range(0, 256)]


class Color8:
    __slots__ = 'n'

    def __init__(self, n):
        self.n = n

    def bg(self):
        return TBL8BG[self.n]

    def fg(self):
        return TBL8FG[self.n]


def bg4(n):
    if n < 8:
        return csi(40 + n) + 'm'

    return csi(92 + n) + 'm'


def fg4(n):
    if n < 8:
        return csi(30 + n) + 'm'

    return csi(82 + n) + 'm'


TBL4BG = [bg4(x) for x in range(0, 16)]
TBL4FG = [fg4(x) for x in range(0, 16)]


class Color4:
    __slots__ = 'n'

    def __init__(self, n):
        self.n = n

    def bg(self):
        return TBL4BG[self.n]

    def fg(self):
        return TBL4FG[self.n]


class PreparedColor:
    __slots__ = ('b', 'f')

    def __init__(self, c):
        self.b = c.bg()
        self.f = c.fg()

    def bg(self):
        return self.b

    def fg(self):
        return self.f


def prepare(c):
    return PreparedColor(c)


class DefaultColor:
    def fg(self):
        return csi(39) + 'm'

    def bg(self):
        return csi(49) + 'm'


def black():
    return Color4(0)


def white():
    return Color4(15)


def gray8(n):
    return Color8(232 + n)


TBLGR24 = [prepare(Color24(i, i, i)) for i in range(0, 256)]


def gray24(n):
    return TBLGR24[n]


class Attrs:
    __slots__ = 't'

    def __init__(self, c=None, b=None, f=None):
        self.t = (c, b, f)

    def fmt(self):
        c, b, f = self.t

        return b.bg() + f.fg() + c

    def combine(self, prev):
        c1, b1, f1 = prev.t
        c2, b2, f2 = self.t

        return Attrs(c=c2 or c1, b=b2 or b1, f=f2 or f1)


class ReverseAttrs:
    __slots__ = ()

    def combine(self, prev):
        c, b, f = prev.t

        return Attrs(c=c, b=f, f=b)


class Async:
    def __init__(self):
        self.q = queue.SimpleQueue()

        threading.Thread(target=self.runq, daemon=True).start()

    def runq(self):
        while True:
            self.q.get()()

    def schedule(self, f):
        self.q.put(f)


def singleton(func):
    @functools.wraps(func)
    def wrapper():
        while True:
            try:
                return func.__result__
            except AttributeError:
                func.__result__ = func()

    return wrapper


@singleton
def asyncmngr():
    return Async()


def schedule(f):
    asyncmngr().schedule(f)


class Display:
    def __init__(self, ch):
        self.ch = ch

        dx, dy = self.ch.dims()

        self.dx = dx
        self.dy = dy
        self.dd = {}

    def flip(self, pixels):
        ds = ''
        dd = self.dd
        bp = {}
        dx = self.dx
        dy = self.dy

        for x, y, n in pixels:
            if x >= 0 and x < dx and y >= 0 and y < dy:
                k = x + y * 10000
                v = bp.get(k)

                if v:
                    bp[k] = (x, y, n.combine(v[2]))
                else:
                    bp[k] = (x, y, n)

        p = None

        for k in sorted(bp.keys()):
            x, y, n = bp[k]

            f = n.fmt()

            if f != dd.get(k):
                dd[k] = f

                if k - 1 == p:
                    pass
                else:
                    ds += move(x, y)

                p = k
                ds += f

        schedule(lambda: self.ch.send(ds))


class Panel:
    def __init__(self, w, h, p):
        self.w = w
        self.h = h
        self.p = p

    def pixels(self, attrs):
        for y in range(0, self.h):
            for x in range(0, self.w):
                yield x, y, self.p


class Handle:
    def __init__(self, w):
        self.w = w
        self.move(0, 0)

    def pixels(self, attrs):
        for x, y, c in self.w.pixels(attrs):
            yield x + self.x, y + self.y, c

    def dispatch(self, ev):
        self.w.dispatch(ev)

    def move(self, x, y):
        self.x = x
        self.y = y


class Stack:
    def __init__(self):
        self.o = []

    def push(self, w):
        h = Handle(w)

        self.o.append(h)

        return h

    def pop(self):
        return self.o.pop()

    def pixels(self, attrs):
        for n, o in enumerate(self.o):
            a = attrs.copy()

            if n == (len(self.o) - 1):
                a['focus'] = attrs['focus']
            else:
                a['focus'] = False

            yield from o.pixels(a)

    def dispatch(self, ev):
        self.o[-1].dispatch(ev)


class Combine(Stack):
    def pixels(self, attrs):
        for o in self.o:
            yield from o.pixels(attrs)


class EventLoop:
    def __init__(self, ch):
        self.d = Display(ch)
        self.i = InputStream(ch)

    def loop(self, w):
        attrs = {'focus': True}

        while True:
            self.d.flip(w.pixels(attrs))
            w.dispatch(self.i.next())


def parse_color(c):
    if c:
        return prepare(Color24(int(c[0:2], 16), int(c[2:4], 16), int(c[4:6], 16)))

    return white()


def guess_lexer(p, d):
    try:
        return pl.guess_lexer_for_filename(p, d)
    except pu.ClassNotFound:
        return pl.guess_lexer(d)


class HighLight:
    CALL = re.compile('([a-zA-Z0-9]\w*)\(')

    DFLT = {
        'dict',
        'list',
        'tuple',
        'deque',
        'int',
        'str',
        'defaultdict',
    }

    def __init__(self, p, d):
        self.lex = guess_lexer(p, d[:10000])
        self.stl = ps.get_style_by_name('material')
        self.lns = {}
        self.col = {}

    def parse_color(self, c):
        while True:
            try:
                return self.col[c]
            except KeyError:
                self.col[c] = parse_color(c)

    def style(self, typ):
        try:
            return self.parse_color(self.stl.style_for_token(typ).get('color', ''))
        except KeyError:
            return white()

    def style_line_impl(self, l):
        extra = dict(self.iter_calls(l))

        for n, (ch, s) in enumerate(self.iter_pygments(l)):
            yield ch, extra.get(n, s)

    def iter_calls(self, l):
        cc = self.style(pt.Name.Class)
        cf = self.style(pt.Name.Function)

        for m in re.finditer(self.CALL, l):
            if m[1][0].islower():
                if m[1] in self.DFLT:
                    co = cc
                else:
                    co = cf
            else:
                co = cc

            for p in range(m.start(1), m.end(1)):
                yield p, co

    def iter_pygments(self, l):
        for typ, text in self.lex.get_tokens(l):
            s = self.style(typ)

            for ch in text:
                if ch == '\n':
                    pass
                else:
                    yield ch, s

    def style_line(self, l):
        if len(self.lns) > 10000:
            self.lns.clear()

        while True:
            try:
                return self.lns[l]
            except KeyError:
                r = list(self.style_line_impl(l))

                if len(l) != len(r):
                    r = [(x, white()) for x in l]

                self.lns[l] = r


class TextArray:
    def __init__(self, d):
        self.d = d
        self.split()

    def split(self):
        self.l = self.d.split('\n')

    def at(self, pos):
        if pos < 0:
            raise IndexError()

        if pos == len(self.d):
            return None

        return self.d[pos]

    def delete(self, fr, to):
        self.d = self.d[:fr] + self.d[to:]
        self.split()

    def insert(self, pos, c):
        self.d = self.d[:pos] + c + self.d[pos:]
        self.split()

    def y(self, pos):
        return self.d[:pos].count('\n')

    def lines(self, fr, to):
        try:
            for i in range(fr, to):
                yield i, self.l[i]
        except IndexError:
            pass

    def length(self):
        return len(self.d)

    def result(self):
        return ('\n'.join(x.rstrip() for x in self.l)).strip() + '\n'

    def search(self, t, fr):
        return self.d.find(t, fr)


class TextCache:
    def __init__(self, t):
        self.t = t
        self.clear()

    def clear(self):
        self.c = {}

    def at(self, pos):
        return self.t.at(pos)

    def insert(self, pos, ch):
        self.clear()
        self.t.insert(pos, ch)

    def delete(self, fr, to):
        self.clear()
        self.t.delete(fr, to)

    def y(self, pos):
        cp = pos - pos % 256

        if cp not in self.c:
            self.c[cp] = self.t.y(cp)

        res = self.c[cp]

        for c in range(cp, pos):
            if self.at(c) == '\n':
                res += 1

        return res

    def lines(self, fr, to):
        return self.t.lines(fr, to)

    def length(self):
        return self.t.length()

    def result(self):
        return self.t.result()

    def search(self, t, fr):
        return self.t.search(t, fr)


def gen_brackets():
    for p in ('()', '[]', '{}'):
        yield p[0], (p[1],  1)
        yield p[1], (p[0], -1)


class SearchContext:
    def __init__(self, e):
        self.e = e

    def search_from(self, t, c):
        p = self.e.t.search(t, c)

        if p >= 0:
            self.e.set_mark(p, p + len(t))
            self.e.set_pos(p)
            self.e.b.pub('cursor', p)

        return p

    def search(self, t):
        self.search_from(t, self.e.c)

    def search_next(self, t):
        if self.search_from(t, self.e.c + 1) < 0:
            self.e.b.msg(f'search wrap: {t}')
            self.search_from(t, 0)


class EmacsSequencer:
    def __init__(self):
        self.state = ''

    def dispatch(self, ev):
        if ev == 'ctrl-x':
            self.state = ev
        else:
            prev = self.state

            self.state = ''

            if prev:
                return prev + '-' + ev

            return ev


class Editor:
    BRKT = dict(gen_brackets())

    def __init__(self, p, b):
        with open(p) as f:
            d = f.read()

        self.s = EmacsSequencer()
        self.h = HighLight(p, d)
        self.t = TextCache(TextArray(d))
        self.c = 0
        self.b = b
        self.unmark()
        self.copy_to_buffer('')

    def get_unmark(self):
        try:
            return self.get_mark()
        finally:
            self.unmark()

    def unmark(self):
        self.set_mark(None, None)

    def set_mark(self, b, e):
        self.mb = b
        self.me = e

    def get_mark(self):
        b = self.mb
        e = self.me

        if b is None:
            b = self.c

        if e is None:
            e = self.c

        if e < b:
            return e, b + 1

        return b, e

    def search_context(self):
        return SearchContext(self)

    def save(self, p):
        t = p + '.tmp'

        with open(t, 'w') as f:
            f.write(self.t.result())

        os.rename(t, p)

    def complete_ratio(self):
        return fractions.Fraction(self.c + 1, self.t.length() + 1)

    def x_for(self, c):
        n = 0

        for c in self.iter_chars_before(c):
            if c == '\n':
                break

            n += 1

        return n

    def y_for(self, c):
        return self.t.y(c)

    def iter_xypc(self, fr, to):
        if fr == to:
            return

        x = self.x_for(fr)
        y = self.y_for(fr)

        for p in range(fr, to):
            c = self.t.at(p)

            if c == '\n':
                x = 0
                y += 1
            else:
                yield x, y, p, c

                x += 1

    @property
    def x(self):
        return self.x_for(self.c)

    @property
    def y(self):
        return self.y_for(self.c)

    def iter_chars_fwd(self, p):
        while True:
            yield p, self.t.at(p)

            p += 1

    def iter_chars_bck(self, p):
        while True:
            yield p, self.t.at(p)

            p -= 1

    def find_bracket_match(self, cur):
        o = self.t.at(cur)

        if o in self.BRKT:
            c, ov = self.BRKT[o]
            tbl = {o: ov, c: -ov}
            cnt = 0

            for p, c in (self.iter_chars_fwd if ov > 0 else self.iter_chars_bck)(cur):
                cnt += tbl.get(c, 0)

                if cnt == 0:
                    return p

    def bracket_match(self):
        try:
            return self.find_bracket_match(self.c)
        except IndexError:
            pass

    def render(self, x1, y1, x2, y2):
        for y, s in self.t.lines(y1, y2):
            l = self.h.style_line(s)

            for x in range(x1, min(x2, len(l))):
                c, col = l[x]

                if c != ' ':
                    yield x, y, Attrs(c=c, f=col)

        for x, y, p, c in self.iter_xypc(*self.get_mark()):
            yield x, y, Attrs(c=c, b=gray8(12))

        bm = self.bracket_match()

        if bm is not None:
            yield self.x_for(bm), self.y_for(bm), Attrs(f=black(), b=Color4(12))

    def iter_chars_before(self, p):
        try:
            for p, c in self.iter_chars_bck(p - 1):
                yield c
        except IndexError:
            pass

    def iter_lines_before(self, p):
        s = ''

        for ch in self.iter_chars_before(p):
            if ch == '\n':
                yield s

                s = ''
            else:
                s = ch + s

        if s:
            yield s

    def get_indent_base_line(self, p):
        for i in itertools.islice(self.iter_lines_before(p), 1, None):
            if i.strip():
                return i

        return ''

    def calc_indent_for(self, l):
        s = ''

        for c in l:
            if c == ' ':
                s += c
            else:
                break

        if l and l[-1] in (':', '{', '[', '('):
            s += '    '
        elif l.strip().split(' ')[0] in ('return', 'break', 'continue', 'raise', 'throw', 'pass'):
            s = s[4:]

        return s

    def calc_indent(self):
        return self.calc_indent_for(self.get_indent_base_line(self.c))

    def ins_indent(self):
        indent = self.calc_indent()

        self.b.msg(f'indent: {indent}')

        for ch in indent:
            self.handle_char(ch)

    def run_indent(self):
        self.key_home()
        self.del_space()
        self.ins_indent()

    def getch(self):
        return self.t.at(self.c)

    def space(self):
        return self.getch() == ' '

    def set_pos(self, c):
        self.t.at(c)
        self.c = c

    def one_right(self):
        self.set_pos(self.c + 1)

    def one_left(self):
        self.set_pos(self.c - 1)

    def del_space(self):
        while self.space():
            self.key_delete()

    def dispatch(self, ev, h):
        seq = self.s.dispatch(ev)

        if seq:
            if len(seq) == 1:
                self.handle_char(seq)
            else:
                self.handle_event(seq, h)

    def begin_mark(self):
        self.set_mark(self.c, None)

    def end_mark(self):
        self.set_mark(self.mb, self.c)

    def key_ctrl_x_c(self):
        self.b.pub('show-save-dialog')

    def key_ctrl_x_ctrl_c(self):
        self.key_ctrl_x_c()

    def key_ctrl_x_s(self):
        self.key_ctrl_s()

    def key_ctrl_x_ctrl_s(self):
        self.key_ctrl_x_s()

    def key_ctrl_space(self):
        self.begin_mark()

    def key_ctrl_w(self):
        self.end_mark()
        self.cut_selection()

    def key_alt_w(self):
        self.end_mark()
        self.copy_selection()

    def key_ctrl_y(self):
        self.paste_from_buffer()

    def paste(self, pos, txt):
        self.t.insert(pos, txt)
        self.set_pos(pos + len(txt))

    def paste_from_buffer(self):
        self.paste(self.c, self.buf)

    def copy_to_buffer(self, txt):
        self.buf = txt

    def get_range(self, fr, to):
        return ''.join(self.t.at(p) for p in range(fr, to))

    def cut_range(self, fr, to):
        try:
            return self.get_range(fr, to)
        finally:
            self.t.delete(fr, to)

    def cut_selection(self):
        fr, to = self.get_unmark()

        self.set_pos(fr)
        self.copy_to_buffer(self.cut_range(fr, to))

    def copy_selection(self):
        self.copy_to_buffer(self.get_range(*self.get_unmark()))

    def key_tab(self):
        self.run_indent()

    def key_pagedown(self, h):
        for i in range(0, h):
            self.key_down()

    def key_pageup(self, h):
        for i in range(0, h):
            self.key_up()

    def key_cr(self):
        self.key_lf()

    def key_lf(self):
        self.handle_char('\n')
        self.run_indent()

    def key_home(self):
        try:
            self.one_left()

            while self.getch() != '\n':
                self.one_left()

            self.one_right()
        except IndexError:
            pass

    def key_end(self):
        while self.getch() != '\n':
            self.one_right()

    def key_left(self):
        self.one_left()

        if self.space():
            while self.space():
                self.one_left()

            self.one_right()

    def key_right(self):
        if self.space():
            while self.space():
                self.one_right()
        else:
            self.one_right()

    def skip_at_max(self, cnt):
        for i in range(0, cnt):
            if self.getch() == '\n':
                break

            self.one_right()

    def key_up(self):
        x = self.x

        self.key_home()
        self.one_left()
        self.key_home()
        self.skip_at_max(x)

    def key_down(self):
        x = self.x

        self.key_end()
        self.one_right()
        self.skip_at_max(x)

    def key_bs(self):
        self.one_left()

        if self.space():
            while self.space():
                self.key_delete()
                self.one_left()

            self.one_right()
        else:
            self.key_delete()

    def key_delete(self):
        self.unmark()
        self.t.delete(self.c, self.c + 1)

    def key_ctrl_s(self):
        self.b.pub('show-search-dialog')

    def handle_event(self, ev, h):
        self.b.msg(ev)

        def unknown():
            self.b.msg(f'do not know to do: {ev}')

        func = getattr(self, 'key_' + ev.replace('-', '_'), unknown)

        try:
            try:
                func()
            except TypeError:
                func(h)
        except IndexError:
            self.b.msg('index error')

    def handle_char(self, ch):
        self.b.msg('unicode: ' + ', '.join(str(x) for x in list(ch.encode())))
        self.unmark()
        self.t.insert(self.c, ch)
        self.one_right()


class ViewPort:
    def __init__(self, w, h, e):
        self.e = e
        self.x = fractions.Fraction(0)
        self.y = fractions.Fraction(0)
        self.w = w
        self.h = h
        self.adjust()

    def pixels(self, attrs):
        bx = int(self.x)
        by = int(self.y)

        for x, y, a in self.e.render(bx, by, bx + self.w, by + self.h):
            yield x - bx, y - by, a

        if attrs['focus']:
            yield self.cx, self.cy, ReverseAttrs()

    @property
    def cx(self):
        return self.e.x - int(self.x)

    @property
    def cy(self):
        return self.e.y - int(self.y)

    def set_width(self, w):
        if self.w != w:
            self.w = w
            self.adjust()

    def dispatch(self, ev):
        self.e.dispatch(ev, self.h)
        self.adjust()

    def adjust(self):
        oy = self.y

        hw = fractions.Fraction(self.w, 2)
        hh = fractions.Fraction(self.h, 2)

        while self.cx < 0:
            self.x -= hw

        while self.cy < 0:
            self.y -= hh

        while self.cx >= self.w:
            self.x += hw

        while self.cy >= self.h:
            self.y += hh

        if oy != self.y:
            self.pub_lineno()

        self.e.b.pub('xy', {
            'x': self.cx,
            'y': self.cy,
        })

    def pub_lineno(self):
        self.e.b.pub('lineno', int(self.y))


class Rect:
    F = [0x2553, 0x2556, 0x255C, 0x2559, 0x2551]
    U = [0x250C, 0x2510, 0x2518, 0x2514, 0x2502]

    def __init__(self, w, h):
        self.w = w
        self.h = h

    def chars(self, focus, **kwargs):
        t = self.F if focus else self.U

        yield 0, 0, t[0]
        yield self.w - 1, 0, t[1]
        yield self.w - 1, self.h - 1, t[2]
        yield 0, self.h - 1, t[3]

        for y in range(1, self.h - 1):
            yield 0, y, t[4]
            yield self.w - 1, y, t[4]

        for x in range(1, self.w - 1):
            yield x, 0, 0x2500
            yield x, self.h - 1, 0x2500

    def pixels(self, attrs):
        for x, y, c in self.chars(**attrs):
            yield x, y, Attrs(c=chr(c))


@contextlib.contextmanager
def channel():
    ch = Channel()

    try:
        yield ch
    finally:
        ch.fini()


class Label:
    def __init__(self, t=''):
        self.t = t

    def pixels(self, attrs):
        for x, c in enumerate(self.t):
            yield x, 0, Attrs(c=c)


class VLine:
    def __init__(self, h):
        self.h = h

    def pixels(self, attrs):
        yield 0, 0, Attrs(c=chr(0x252C))
        yield 0, self.h - 1, Attrs(c=chr(0x2534))

        a = Attrs(c=chr(0x2502))

        for y in range(1, self.h - 1):
            yield 0, y, a


class LineNo:
    def __init__(self, s, h):
        self.s = s
        self.h = h

    def set_lineno(self, s):
        self.s = s

    def width(self):
        return len(str(self.s + self.h))

    def pixels(self, attrs):
        f = gray8(8)

        for x, y, c in self.chars():
            yield x, y, Attrs(c=c, f=f)

    def chars(self):
        w = self.width()

        for y, s in enumerate(range(self.s, self.s + self.h)):
            l = str(s)
            dx = w - len(l)

            for x, c in enumerate(l):
                yield dx + x, y, c


class HGrad:
    def __init__(self, w):
        self.w = w

    def pixels(self, attrs):
        for i in range(0, self.w):
            yield i, 0, Attrs(b=gray24(32 - (i * 32) // self.w))


class TextInput:
    def __init__(self, w):
        self.w = w
        self.reset()

    def reset(self):
        self.x = 0
        self.c = 0
        self.t = ''

    def on_text_change(self):
        pass

    def on_complete(self):
        pass

    @property
    def cx(self):
        return self.c - self.x

    def render(self):
        for x, c in enumerate(self.t):
            yield x, Attrs(c=c)

        yield self.c, Attrs(f=black(), b=white())

    def pixels(self, attrs):
        x1 = self.x
        x2 = x1 + self.w

        for x, a in self.render():
            if x >= x1 and x < x2:
                yield x - x1, 0, a

    def dispatch(self, ev):
        try:
            if len(ev) == 1:
                self.dispatch_chr(ev)
                self.key_right()
            else:
                self.dispatch_ev(ev)
        except IndexError:
            pass

        self.adjust()

    def dispatch_chr(self, ch):
        self.t = self.t[:self.c] + ch + self.t[self.c:]
        self.on_text_change()

    def at(self, p):
        if p < 0:
            raise IndexError()

        if p == len(self.t):
            return None

        return self.t[p]

    def set_pos(self, p):
        self.at(p)
        self.c = p

    def key_bs(self):
        self.key_left()
        self.key_delete()

    def key_delete(self):
        self.t = self.t[:self.c] + self.t[self.c + 1:]
        self.on_text_change()

    def key_left(self):
        self.set_pos(self.c - 1)

    def key_right(self):
        self.set_pos(self.c + 1)

    def dispatch_ev(self, ev):
        getattr(self, 'key_' + ev.replace('-', '_'), self.on_complete)()

    def adjust(self):
        hw = self.w // 2

        while self.cx < 0:
            self.x -= hw

        while self.cx >= self.w:
            self.x += hw


class YesNo(Label):
    def on_yes(self):
        pass

    def on_no(self):
        pass

    def dispatch(self, ev):
         if ev == 'y':
             self.on_yes()
         else:
             self.on_no()


def editor_widget(ed, bus, w, h):
    mw_w = Stack()

    st_w = mw_w.push(Combine()).w

    st_w.push(Panel(w, h, Attrs(c=' ', b=prepare(DefaultColor()), f=white())))
    st_w.push(Rect(w, h))

    ln_w = LineNo(0, h - 2)
    vl_w = VLine(h)
    lb_w = Label()
    cp_w = HGrad(w - 2)
    pp_w = Panel(1, 1, Attrs(b=gray8(14)))
    vp_w = ViewPort(w, h - 2, ed)

    class SearchInput(TextInput):
        def on_text_change(self):
            bus.pub('search', self.t)

        def key_ctrl_s(self):
            bus.pub('search-next', self.t)

        def on_complete(self):
            bus.pub('popw')

    ti_w = SearchInput(w - 2)

    class SaveDialog(YesNo):
        def __init__(self):
            YesNo.__init__(self, 'save file, y/n?')

        def on_complete(self):
            bus.pub('popw')

            raise KeyboardInterrupt()

        def on_yes(self):
            bus.pub('save')
            self.on_complete()

        def on_no(self):
            self.on_complete()

    sd_w = SaveDialog()

    ln_h = st_w.push(ln_w)
    vl_h = st_w.push(vl_w)
    lb_h = st_w.push(lb_w)
    cp_h = st_w.push(cp_w)
    pp_h = st_w.push(pp_w)
    vp_h = st_w.push(vp_w)

    def on_popw():
        mw_w.pop()

    def on_lineno(ln):
        ln_w.set_lineno(ln)
        ln_h.move(1, 1)
        vl_h.move(ln_h.x + ln_w.width(), 0)
        lb_h.move(1, 0)
        vp_h.move(vl_h.x + 1, 1)
        vp_w.set_width(w - 2 - vl_h.x)

    def on_message(m):
        lb_w.t = m

    def on_cursor(c):
        vp_w.adjust()

    def on_xy(c):
        pp_h.move(vl_h.x, int(ln_h.y + (ln_w.h - 1) * ed.complete_ratio()))
        cp_h.move(1, vp_h.y + c['y'])

    def on_show_search_dialog():
        ti_w.reset()
        mw_w.push(ti_w).move(1, h - 1)

    def on_search(t):
        bus.msg(f'search for: {t}')
        ed.search_context().search(t)

    def on_search_next(t):
        bus.msg(f'search next: {t}')
        ed.search_context().search_next(t)

    def on_show_save_dialog():
        mw_w.push(sd_w).move(1, h - 1)

    for k in list(locals()):
        if k.startswith('on_'):
            bus.sub(k[3:].replace('_', '-'), locals()[k])

    vp_w.pub_lineno()

    return mw_w


def main():
    fn = sys.argv[1]
    ed = Editor(fn, PubSub())

    try:
        with channel() as ch:
            while True:
                ed.b.sub('save', lambda: ed.save(fn))

                try:
                    ev = EventLoop(ch)

                    return ev.loop(editor_widget(ed, ed.b, ev.d.dx, ev.d.dy))
                except SigWinch:
                    pass

                ed.b = PubSub()
    except KeyboardInterrupt:
        raise
    except:
        ed.save(fn + '.bak')

        raise


try:
    if os.environ.get('PROFILE', ''):
        cProfile.run('main()')
    else:
        main()
except KeyboardInterrupt:
    pass
