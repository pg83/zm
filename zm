#!/usr/bin/env python3

import os
import sys
import json
import yaml
import queue
import base64
import shutil
import pickle
import hashlib
import profile
import argparse
import platform
import threading
import subprocess
import collections

## colors

ATTRIBUTES = dict(
    list(zip(
        [
            'bold',
            'dark',
            '',
            'underline',
            'blink',
            '',
            'reverse',
            'concealed'
        ], list(range(1, 9)))))

del ATTRIBUTES['']

ATTRIBUTES['light'] = ATTRIBUTES['bold']

HIGHLIGHTS = dict(
    list(zip([
        'on_grey',
        'on_red',
        'on_green',
        'on_yellow',
        'on_blue',
        'on_magenta',
        'on_cyan',
        'on_white'
    ], list(range(40, 48)))))

COLORS = dict(
    list(zip([
        'steel',
        'red',
        'green',
        'yellow',
        'blue',
        'magenta',
        'cyan',
        'white',
    ], list(range(30, 38)))))

COLORS['reset'] = 0


def get_code(code):
    return "\033[{}m".format(code)


def get_color_0(color, on_color):
    res = ''

    if color is not None:
        res += get_code(COLORS[color])

    if on_color is not None:
        res += get_code(HIGHLIGHTS[on_color])

    return res


def color_key(color, on_color):
    return str(color) + '-' + str(on_color)


def iter_all_colors():
    for c in list(COLORS.keys()) + [None]:
        for o in list(HIGHLIGHTS.keys()) + [None]:
            yield color_key(c, o), get_color_0(c, o)


CC = dict(iter_all_colors())


def get_color_ext(color, on_color=None, attrs=[]):
    res = CC[color_key(color, on_color)]

    for attr in attrs:
        res += get_code(ATTRIBUTES[attr])

    return res


def iter_synonyms():
    for c in COLORS:
        if c == 'reset':
            continue

        yield c[0], c
        yield c, c


def iter_combo():
    attrs = [[], ['bold'], ['dark'], ['bold', 'dark']]

    for s, c in iter_synonyms():
        for a in attrs:
            if len(s) == 1:
                aa = [x[0] for x in a]
            else:
                aa = a

            name = ''.join(aa + [s])
            b = [x for x in a]

            yield name, c, b
            yield '{' + name + '}', c, b


def iter_full_table():
    for n, c, a in iter_combo():
        yield n, get_color_ext(c, on_color=None, attrs=a)

    for r in ('', 'rst', 'reset'):
        yield r, get_code(0)
        yield '{' + r + '}', get_code(0)


COLOR_TABLE = dict(iter_full_table())


def get_color(n):
    return COLOR_TABLE[n]


def colorize(text, color):
    return get_color(color) + text + get_color('')


MM = set()
ML = threading.Lock()

def msg(l, c, msg):
    m  = colorize('[' + l + '] ', c)
    m += colorize('(' + struct_hash(threading.get_ident())[:5] + ') ', 'bb')
    m += msg.replace('$(S)', colorize('$(S)', 'bg')).replace('$(B)', colorize('$(B)', 'by'))

    with ML:
        if m in MM:
            return

        MM.add(m)

        print(m)


## end color


def filter_cmd_out(o):
    def iter_lines():
        for l in o.split('\n'):
            if 'creating archive' in l:
                continue

            if 'has no symbols' in l:
                continue

            yield l

    return '\n'.join(iter_lines()).strip()


def run_cmd(cmd):
    p = subprocess.Popen(cmd, shell=False, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    out, err = p.communicate()
    code = p.wait()
    out = filter_cmd_out(out.decode('utf-8'))

    if code:
        raise Exception((' '.join(cmd) + ' with exit code ' + str(code) + '\n' + out).strip())

    return out


def join_path(a, b):
    if not a:
        return b

    if not b:
        return a

    return a + '/' + b


def iter_uniq_list_slow(l):
    v = set()

    for x in l:
        k = struct_hash(x)

        if k not in v:
            v.add(k)

            yield x


def iter_uniq_list(l):
    v = set()

    for x in l:
        try:
            if x in v:
                continue
        except Exception:
            yield from iter_uniq_list_slow(l)

            return

        v.add(x)

        yield x


def uniq_list(l):
    return list(iter_uniq_list(l))


def singleton(f):
    def wrapper():
        try:
            wrapper.__res__
        except AttributeError:
            wrapper.__res__ = f()

        return wrapper.__res__

    return wrapper


def cached_method(meth):
    def wrapper(self, *args, **kwargs):
        try:
            self.__cache__
        except Exception:
            self.__cache__ = {}

        d = self.__cache__
        k = struct_hash([args, kwargs, meth.__name__])

        if k not in d:
            d[k] = object()
            d[k] = meth(self, *args, **kwargs)

        return d[k]

    return wrapper


@singleton
def find_root():
    res = os.path.dirname(os.path.normpath(os.path.abspath(__file__)))

    msg('R', 'by', res)

    return res


def get_target(t):
    return os.path.normpath(os.path.abspath(os.path.join(os.getcwd(), t)))


def strip_prefix(s, p):
    assert s.startswith(p), 'out of root build'

    return s[len(p) + 1:]


def get_substr(s, b, e):
    p = s.find(b)

    if p < 0:
        return None

    s = s[p + len(b):]
    p = s.find(e)

    assert p > 0

    s = s[:p]

    return b + s + e


def parse_cpp_includes(data):
    for l in data.splitlines():
        l = l.strip()

        if not l:
            continue

        ll = l.replace(' ', '').replace('\t', '')

        if not ll.startswith('#include'):
            continue

        ll = ll.replace('_LIBCPP_EXTERNAL_THREADING', '<__external_threading>')

        if res := get_substr(ll, '<', '>'):
            yield res
        elif res := get_substr(ll, '"', '"'):
            yield res
        elif res := get_substr(ll, '(', ')'):
            yield res
        else:
            raise Exception('unparsed include ' + l)


def to_bd(p):
    return p.replace('$(S)', '$(B)')


def to_sd(p):
    return p.replace('$(B)', '$(S)')


def fext(p):
    return os.path.basename(p).split('.')[-1]


def strip_ext(p):
    return p[:-1 - len(fext(p))]


class Module(object):
    def __init__(self, data, parser, prefix):
        self._d = data
        self._p = prefix
        self._parser = parser

    def extra_depends(self):
        return []

    @property
    def name(self):
        return self._d['name']

    @property
    @cached_method
    def depends(self):
        return uniq_list(self._d.get('depends', []) + self.extra_depends())

    @property
    @cached_method
    def inc_dirs(self):
        return uniq_list(self.global_inc_dirs() + self._d.get('inc_dirs', []))

    @cached_method
    def global_inc_dirs(self):
        def iter_dirs():
            yield from self._d.get('global_inc_dirs', [])

            for sm in self.iter_sub_modules(self.depends):
                yield from sm.global_inc_dirs()

        return uniq_list(iter_dirs())

    @property
    def c_flags(self):
        return self._d.get('c_flags', []) + self._d.get('c_only_flags', [])

    @property
    def cxx_flags(self):
        return self._d.get('c_flags', []) + self._d.get('cxx_flags', [])

    @property
    def ld_flags(self):
        return self._d.get('ld_flags', [])

    @property
    def parser(self):
        return self._parser

    @property
    def prefix(self):
        return self._p

    @property
    def srcs(self):
        return [('$(S)/' + self.prefix + '/' + x) for x in self._d.get('srcs', [])]

    @property
    def join_srcs(self):
        return [('$(S)/' + self.prefix + '/' + x) for x in self._d.get('join_srcs', [])]

    @property
    def compiler(self):
        return self.parser.compiler

    def src_path(self, p):
        return os.path.normpath(self.parser.replace_path(p))

    def parse_includes(self, pp):
        v = set()

        def do(p):
            if p in v:
                return

            v.add(p)

            p = self.find_location(p, os.path.dirname(pp))

            yield p

            if from_sd(p):
                for i in self.parser.inc_parser.parse_cpp_includes(self.src_path(p)):
                    yield from do('$(S)/' + i[1:-1])

        yield from do(pp)

    def find_location(self, p, w):
        def it():
            yield w
            yield from self.iter_inc_dirs()

        for x in iter_uniq_list(it()):
            pp = p.replace('$(S)', x)
            spp = self.src_path(pp)

            if self.parser.loader.exists(spp):
                return pp

        return to_bd(p)

    def iter_inc_dirs(self):
        yield '$(S)'

        for x in self.inc_dirs:
            yield '$(S)/' + x

    def parse_includes_md5(self, p):
        def it():
            for i in self.parse_includes(p):
                if from_bd(i):
                    yield {
                        'path': i,
                    }
                else:
                    yield {
                        'path': i,
                        'md5': self.parser.md5_calcer.get_md5(self.src_path(i)),
                    }

        return list(it())

    def build_command_1(self, src):
        by_ext = {
            'C': self.cxx_compile_command,
            'cc': self.cxx_compile_command,
            'cxx': self.cxx_compile_command,
            'cpp': self.cxx_compile_command,
            'c': self.c_compile_command,
            'S': self.c_compile_command,
            's': self.c_compile_command,
            'file2c': self.file2c_command,
            'asm': self.yasm_command,
        }

        def nope(src):
            return []

        return by_ext.get(fext(src), nope)(src)

    def build_command_0(self, src):
        to_v = [src]
        v = set()

        while to_v:
            s = to_v.pop()

            if s in v:
                continue

            v.add(s)

            for c in self.build_command_1(s):
                yield c

                for o in c['out']:
                    to_v.append(o)

    def build_command(self, src):
        return list(self.build_command_0(src))

    def join_srcs_command(self, srcs):
        o = '$(B)/' + self.prefix + '/' + struct_hash('_'.join(srcs)) + '.' + fext(srcs[0])

        def iter_inc():
            for s in srcs:
                yield from self.parse_includes_md5(s)

        def iter_cmds():
            for l in srcs:
                yield ['/bin/sh', '-c', 'echo "#include \\"' + l + '\\"" >> ' + o]

        return {
            'in': srcs,
            'out': [o],
            'cmd': list(iter_cmds()),
            'inc': list(iter_inc()),
        }

    def file2c_command(self, src):
        o = to_bd(strip_ext(src) + '.h')

        return [
            {
                'in': [src, '$(B)/tp/tools/file2c/file2c'],
                'out': [o],
                'cmd': [
                    ['/bin/sh', '-c', '$(B)/tp/tools/file2c/file2c < ' + src + ' > ' + o],
                ],
                'depends': ['tp/tools/file2c'],
                'inc': self.parse_includes_md5(src),
            },
        ]

    def yasm_command(self, src):
        o = to_bd(strip_ext(src) + '.o')
        t = self.parser.target

        def iter_flags():
            for f in t.defines:
                yield '-D'
                yield f

        return [
            {
                'in': [src, '$(B)/tp/tools/yasm/yasm'],
                'out': [o],
                'cmd': [
                    [
                        '$(B)/tp/tools/yasm/yasm', '-f', t.complete_exe_format] + list(iter_flags()) + ['-D', '_YASM_', '-I', '$(S)', '-o', o, src
                    ],
                ],
                'depends': ['tp/tools/yasm'],
            },
        ]

    def c_compile_command(self, src):
        o = to_bd(src + '.o')

        return [
            {
                'in': [src],
                'out': [o],
                'cmd': self.compiler.c_compile_command(src, o, list(self.iter_inc_dirs()) + ['$(B)'], self.c_flags),
                'inc': self.parse_includes_md5(src),
            },
        ]

    def cxx_compile_command(self, src):
        o = to_bd(src + '.o')

        return [
            {
                'in': [src],
                'out': [o],
                'cmd': self.compiler.cxx_compile_command(src, o, list(self.iter_inc_dirs()) + ['$(B)'], self.cxx_flags),
                'inc': self.parse_includes_md5(src),
            },
        ]

    def link_command(self, srcs, out):
        o = '$(B)/' + self.prefix + '/' + out

        return {
            'in': srcs,
            'out': [o],
            'cmd': self.compiler.link_command(srcs, o, self.ld_flags) + [
                ['ln', '-f', o, to_sd(o)],
            ],
        }

    def ar_command(self, srcs, out):
        o = '$(B)/' + self.prefix + '/' + out

        return {
            'in': srcs,
            'out': [o],
            'cmd': self.compiler.ar_command(srcs, o),
        }

    def iter_simple_commands(self):
        for s in self.srcs:
            yield from self.build_command(s)

        js = self.join_srcs

        if js:
            cmd = self.join_srcs_command(js)

            yield cmd

            for o in cmd['out']:
                yield from self.build_command(o)

    def iter_sub_modules(self, deps):
        for d in deps:
            yield self.parser.parse_module(d)

    def iter_sub_commands(self, deps):
        def do():
            for d in self.iter_sub_modules(deps):
                yield from d.commands()

        return do()

    def calc_commands(self):
        # compile
        cc = list(self.iter_simple_commands())

        def iter_ss():
            for l in cc:
                for o in l['out']:
                    if o.endswith('.o'):
                        yield o

        ss = list(iter_ss())

        def iter_depends():
            yield from self.depends

            for l in cc:
                yield from l.get('depends', [])

        # libs
        dc = list(self.iter_sub_commands(iter_depends()))

        return cc, ss, dc


class SystemCompiler(object):
    def compile_command(self, cxx, src, out, inc, flags):
        return [
            cxx + ['-I' + x for x in inc] + ['-fcolor-diagnostics'] + flags + ['-c', '-o', out, src],
        ]

    def c_compile_command(self, src, out, inc, flags):
        return self.compile_command(['clang'], src, out, inc, flags)

    def cxx_compile_command(self, src, out, inc, flags):
        return self.compile_command(['clang++'], src, out, inc, ['-std=c++17', '-nostdinc++'] + flags)

    def link_command(self, srcs, out, flags):
        return [['clang++', '-o', out] + ['-nostdlib++', '-fcolor-diagnostics'] + flags + srcs]

    def ar_command(self, srcs, out):
        return [['ar', 'q', out] + srcs]


class Program(Module):
    def __init__(self, data, parser, prefix):
        Module.__init__(self, data, parser, prefix)

    @cached_method
    def commands(self):
        cc, ss, dc = self.calc_commands()

        def iter_ls():
            for l in dc:
                for o in l['out']:
                    if o.endswith('.a'):
                        yield o

        ls = list(iter_ls())

        return cc + dc + [self.link_command(uniq_list(ss + ls), self.name)]

    def iter_extra_deps(self):
        yield 'tp/libs/libcxx'

        if self.name not in ['yasm']:
            yield 'tp/libs/libasmlib'

    def extra_depends(self):
        return list(self.iter_extra_deps())


class Library(Module):
    exclude = frozenset([
        'tpcxxinclude',
        'tpcxxsrc',
        'tpcxxrt',
        'tpunwindsrc',
        'tpdemangle',
    ])

    def __init__(self, data, parser, prefix):
        Module.__init__(self, data, parser, prefix)

    @cached_method
    def commands(self):
        cc, ss, dc = self.calc_commands()

        return cc + dc + [self.ar_command(ss, 'lib' + self.name + '.a')]

    def extra_depends(self):
        if self.name not in self.exclude:
            return ['tp/libs/libcxx']

        return []


class Recurse(Module):
    def __init__(self, data, parser, prefix):
        Module.__init__(self, data, parser, prefix)

    @property
    def recurse(self):
        return self._d['recurse']

    @property
    def depends(self):
        def iter_deps():
            for d in self.recurse:
                yield join_path(self.prefix, d)

        return list(iter_deps())

    @cached_method
    def commands(self):
        def iter_cc():
            for d in self.iter_sub_modules(self.depends):
                yield from d.commands()

        return list(iter_cc())


class Parser(object):
    def __init__(self, root, compiler, target, inc_parser):
        self._r = root
        self._c = compiler
        self._i = inc_parser
        self._t = target

    @property
    def md5_calcer(self):
        return self._i.md5_calcer

    @property
    def target(self):
        return self._t

    @property
    def inc_parser(self):
        return self._i

    @property
    def loader(self):
        return self.inc_parser.loader

    @property
    def compiler(self):
        return self._c

    @property
    def root(self):
        return self._r

    def replace_path(self, p):
        return p.replace('$(S)', self.root)

    @cached_method
    def parse_module(self, target):
        msg('T', 'bc', '$(S)/' + target)

        with open(os.path.join(self.root, target, 'z.make'), 'r') as f:
            d = yaml.load(f.read(), Loader=yaml.Loader)

        if 'recurse' in d:
            return Recurse(d, self, target)

        m = d['module']

        if m == 'program':
            if 'name' not in d:
                d['name'] = os.path.basename(target)

            return Program(d, self, target)

        if m == 'library':
            if 'name' not in d:
                d['name'] = target.replace('/libs/', '').replace('/', '_').replace('-', '_').replace('_', '').replace('lib', '')

            return Library(d, self, target)

        raise Exception('unsupported module ' + m)


def from_bd(i):
    return i[2] == 'B'


def from_sd(i):
    return i[2] == 'S'


def struct_hash(s):
    return hashlib.md5(json.dumps(s, sort_keys=True).encode('utf-8')).hexdigest()[:10]


def build_uids(g):
    by_out = {}

    for n in g:
        for o in n['out']:
            by_out[o] = n

    def uid(n):
        if 'uid' not in n:
            deps = []

            def iter_in():
                for i in n['in']:
                    if from_bd(i):
                        yield i

                for f in n.get('inc', []):
                    if 'md5' not in f:
                        yield f['path']

            for i in iter_in():
                if i in by_out:
                    deps.append(uid(by_out[i]))
                else:
                    msg('U', 'br', i)

            n['deps'] = deps
            n['uid'] = struct_hash(n)

        return n['uid']

    by_uid = {}
    res = []

    for n in g:
        u = uid(n)

        if u not in by_uid:
            by_uid[u] = n
            res.append(n)

    return res


def prepare_dir(ro):
    try:
        os.makedirs(os.path.dirname(ro))
    except OSError:
        pass


def simple_engine(it):
    by_dep = collections.defaultdict(set)
    by_rdep = collections.defaultdict(set)

    for k, v in it:
        by_dep[k].add(v)
        by_rdep[v].add(k)

    deps = set(by_dep.keys())
    rdeps = set(by_rdep.keys())
    ready = rdeps - deps

    def iter_ready():
        while ready:
            tmp = list(sorted(ready))

            ready.clear()

            for t in tmp:
                if t is not None:
                    yield t
                else:
                    cb(None)

    def cb(item):
        for k in by_rdep[item]:
            el = by_dep[k]

            el.remove(item)

            if not el:
                by_dep.pop(k)
                ready.add(k)

    return iter_ready, cb


class SimpleBuilder(object):
    def __init__(self, g, parser, build_dir):
        self._g = g
        self._p = parser
        self._bd = build_dir
        self._bu = {}

        for n in self._g:
            self._bu[n['uid']] = n

    def visit(self):
        v = set()

        def visit(n):
            u = n['uid']

            if u not in v:
                v.add(u)

                for d in n['deps']:
                    yield from visit(self._bu[d])

                yield n

        for n in self._g:
            yield from visit(n)

    def replace_path(self, p, n, w):
        bp = p.replace('$(B)', self._bd + '/$(W)/' + n['uid'][:2] + '/' + n['uid'][2:]).replace('$(W)', w)

        return self._p.replace_path(bp)

    def build(self):
        for n in self.visit():
            self.build_command(n)

    def iter_deps(self):
        for n in self._g:
            for d in n['deps']:
                yield n['uid'], d

    def build_parallel(self, th):
        r, w = simple_engine(self.iter_deps())

        qi = queue.SimpleQueue()
        qo = queue.SimpleQueue()

        v = set()

        def make_func(d):
            def func():
                return d

            return func

        def make_err(n, e):
            def func():
                raise Exception('while build ' + ' '.join(n['out']) + ': ' + str(e))

            return func

        def run_thr():
            while True:
                d = qi.get()
                n = self._bu[d]

                try:
                    self.build_command(n)
                    qo.put(make_func(d))
                except Exception as e:
                    qo.put(make_err(n, e))

        for i in range(0, th):
            t = threading.Thread(target=run_thr)
            t.daemon = True
            t.start()

        while True:
            for i in r():
                qi.put(i)
                v.add(i)

            if not v:
                return

            res = qo.get()()

            w(res)
            v.remove(res)

    def build_command(self, n):
        where_c = self.replace_path('$(B)', n, 'c')
        where_t = self.replace_path('$(B)', n, 't')

        if os.path.exists(where_c):
            return

        shutil.rmtree(where_t, ignore_errors=True)

        for o in n['out']:
            prepare_dir(self.replace_path(o, n, 't'))

        for d in n['deps']:
            dn = self._bu[d]

            shutil.copytree(self.replace_path('$(B)', dn, 'c'), where_t, dirs_exist_ok=True)

        m = []

        def app_msg(ms):
            if ms:
                m.append(ms)

        app_msg(' '.join(n['out']))

        for c in n['cmd']:
            cmd = [self.replace_path(x, n, 't') for x in c]

            app_msg(colorize(' '.join(cmd), 'dw'))
            app_msg(run_cmd(cmd))

        msg('B', 'bg', '\n'.join(m).strip())

        shutil.move(where_t, where_c)


class Target(object):
    def __init__(self, os, arch):
        self.os = os
        self.arch = arch

    @property
    @cached_method
    def bits(self):
        if 'ARCH_X86_64' in self.flags:
            return 64

        if 'ARCH_AARCH64' in self.flags:
            return 64

        return 32

    @property
    @cached_method
    def is_unix(self):
        return self.os in ['darwin', 'linux', 'freebsd']

    @property
    @cached_method
    def flags(self):
        def iter_flags_0():
            yield 'os_' + self.os
            yield 'arch_' + self.arch

            if self.is_unix:
                yield 'os_unix'

        def iter_flags_1():
            for f in iter_flags_0():
                yield f.upper()

        return list(iter_flags_1())

    @property
    @cached_method
    def defines(self):
        def iter_defines_0():
            yield self.os
            yield self.arch

            if self.is_unix:
                yield 'unix'

        def iter_defines_1():
            for f in iter_defines_0():
                yield f.upper()
                yield '_' + f + '_'

        return list(iter_defines_1())

    @property
    @cached_method
    def exe_format(self):
        if 'OS_DARWIN' in self.flags:
            return 'macho'

        return 'elf'

    @property
    @cached_method
    def complete_exe_format(self):
        return self.exe_format + str(self.bits)


@singleton
def run_target():
    return Target(platform.system().lower(), platform.machine().lower())


class FileLoader(object):
    @cached_method
    def get_data(self, p):
        msg('L', 'by', p)

        with open(p, 'r') as f:
            return f.read()

    @cached_method
    def get_mtime(self, p):
        return os.stat(p).st_mtime

    @cached_method
    def exists(self, p):
        try:
            self.get_mtime(p)

            return True
        except Exception:
            return False


class MD5Calcer(object):
    LOADER = FileLoader()

    def get_md5(self, p):
        return self.calc_md5(p, self.loader.get_mtime(p))

    @cached_method
    def calc_md5(self, p, mt):
        return struct_hash(self.loader.get_data(p))

    @property
    def loader(self):
        return self.LOADER


class IncParser(object):
    def __init__(self, md5_calcer):
        self._m = md5_calcer

    def parse_cpp_includes(self, p):
        return self.parse_cpp_includes_0(p, self._m.get_md5(p))

    @cached_method
    def parse_cpp_includes_0(self, p, md5):
        msg('P', 'bm', p)

        return list(parse_cpp_includes(self.loader.get_data(p)))

    @property
    def loader(self):
        return self.md5_calcer.loader

    @property
    def md5_calcer(self):
        return self._m


def main(args):
    build_dir = os.path.join(os.path.expanduser('~'), '.zbuild')

    if args.clear:
        shutil.rmtree(build_dir, ignore_errors=True)

    try:
        os.makedirs(build_dir)
    except OSError:
        pass

    cache = os.path.join(build_dir, 'cache')

    try:
        with open(cache, 'rb') as f:
            inc = pickle.loads(f.read())
    except Exception as e:
        inc = IncParser(MD5Calcer())

    p = Parser(find_root(), SystemCompiler(), run_target(), inc)
    t = strip_prefix(get_target(args.target), p.root)
    m = p.parse_module(t)
    g = build_uids(m.commands())

    with open(cache, 'wb') as f:
        f.write(pickle.dumps(inc))

    if args.verbose:
        print(json.dumps(g, indent=4, sort_keys=True))

    SimpleBuilder(g, p, build_dir).build_parallel(16)


if __name__ == '__main__':
    argp = argparse.ArgumentParser()

    argp.add_argument('target', nargs='?', default='.')
    argp.add_argument('-v', '--verbose', help='verbose mode', default=False, action='store_const', const=True)
    argp.add_argument('--clear', help='clear cache', default=False, action='store_const', const=True)
    argp.add_argument('--profile', help='run profiler', default=False, action='store_const', const=True)

    args = argp.parse_args(sys.argv[1:])

    def run():
        if args.verbose:
            main(args)
        else:
            try:
                main(args)
            except Exception as e:
                print(e)

    if args.profile:
        profile.run('run()')
    else:
        run()
