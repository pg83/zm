#!/usr/bin/env python3

import os
import sys
import json
import yaml
import hashlib
import argparse
import subprocess
import shutil


## colors

ATTRIBUTES = dict(
    list(zip(
        [
            'bold',
            'dark',
            '',
            'underline',
            'blink',
            '',
            'reverse',
            'concealed'
        ], list(range(1, 9)))))

del ATTRIBUTES['']

ATTRIBUTES['light'] = ATTRIBUTES['bold']

HIGHLIGHTS = dict(
    list(zip([
        'on_grey',
        'on_red',
        'on_green',
        'on_yellow',
        'on_blue',
        'on_magenta',
        'on_cyan',
        'on_white'
    ], list(range(40, 48)))))

COLORS = dict(
    list(zip([
        'steel',
        'red',
        'green',
        'yellow',
        'blue',
        'magenta',
        'cyan',
        'white',
    ], list(range(30, 38)))))

COLORS['reset'] = 0


def get_code(code):
    return "\033[{}m".format(code)


def get_color_0(color, on_color):
    res = ''

    if color is not None:
        res += get_code(COLORS[color])

    if on_color is not None:
        res += get_code(HIGHLIGHTS[on_color])

    return res


def color_key(color, on_color):
    return str(color) + '-' + str(on_color)


def iter_all_colors():
    for c in list(COLORS.keys()) + [None]:
        for o in list(HIGHLIGHTS.keys()) + [None]:
            yield color_key(c, o), get_color_0(c, o)


CC = dict(iter_all_colors())


def get_color_ext(color, on_color=None, attrs=[]):
    res = CC[color_key(color, on_color)]

    for attr in attrs:
        res += get_code(ATTRIBUTES[attr])

    return res


def iter_synonyms():
    for c in COLORS:
        if c == 'reset':
            continue

        yield c[0], c
        yield c, c


def iter_combo():
    attrs = [[], ['bold'], ['dark'], ['bold', 'dark']]

    for s, c in iter_synonyms():
        for a in attrs:
            if len(s) == 1:
                aa = [x[0] for x in a]
            else:
                aa = a

            name = ''.join(aa + [s])
            b = [x for x in a]

            yield name, c, b
            yield '{' + name + '}', c, b


def iter_full_table():
    for n, c, a in iter_combo():
        yield n, get_color_ext(c, on_color=None, attrs=a)

    for r in ('', 'rst', 'reset'):
        yield r, get_code(0)
        yield '{' + r + '}', get_code(0)


COLOR_TABLE = dict(iter_full_table())


def get_color(n):
    return COLOR_TABLE[n]


def colorize(text, color):
    return get_color(color) + text + get_color('')


MM = set()


def msg(l, c, msg):
    m = colorize('[' + l + '] ', c) + msg.replace('$(S)', colorize('$(S)', 'bg')).replace('$(B)', colorize('$(B)', 'by'))

    if m in MM:
        return

    MM.add(m)

    print(m)


## end color


def iter_uniq_list(l):
    v = set()

    for x in l:
        if x not in v:
            v.add(x)

            yield x


def uniq_list(l):
    return list(iter_uniq_list(l))


def singleton(f):
    def wrapper():
        try:
            wrapper.__res__
        except AttributeError:
            wrapper.__res__ = f()

        return wrapper.__res__

    return wrapper


def cached_method(meth):
    def wrapper(self, *args, **kwargs):
        try:
            self.__cache__
        except Exception:
            self.__cache__ = {}

        d = self.__cache__
        k = struct_hash([args, kwargs, meth.__name__])

        if k not in d:
            d[k] = meth(self, *args, **kwargs)

        return d[k]

    return wrapper


@singleton
def find_root():
    res = os.path.dirname(os.path.normpath(os.path.abspath(__file__)))

    msg('R', 'by', res)

    return res


def get_target(t):
    path = os.path.join(os.getcwd(), t)

    return os.path.normpath(os.path.abspath(path))


def strip_prefix(s, p):
    assert s.startswith(p), 'out of root build'

    return s[len(p) + 1:]


def get_substr(s, b, e):
    p = s.find(b)

    if p < 0:
        return None

    s = s[p + len(b):]
    p = s.find(e)

    assert p > 0

    s = s[:p]

    return b + s + e


def parse_cpp_includes(p):
    msg('P', 'bm' ,p)

    with open(p, 'r') as f:
        data = f.read()

    for l in data.splitlines():
        l = l.strip()

        if not l:
            continue

        ll = l.replace(' ', '').replace('\t', '')

        if not ll.startswith('#include'):
            continue

        ll = ll.replace('_LIBCPP_EXTERNAL_THREADING', '<__external_threading>')

        if res := get_substr(ll, '<', '>'):
            yield res
        elif res := get_substr(ll, '"', '"'):
            yield res
        elif res := get_substr(ll, '(', ')'):
            yield res
        else:
            raise Exception('unparsed include ' + l)


class IncParser(object):
    @cached_method
    def parse_cpp_includes(self, p):
        return list(parse_cpp_includes(p))


def to_bd(p):
    return p.replace('$(S)', '$(B)')


def to_sd(p):
    return p.replace('$(B)', '$(S)')


def fext(p):
    return os.path.basename(p).split('.')[-1]


def strip_ext(p):
    return p[:-1 - len(fext(p))]


class Module(object):
    def __init__(self, data, parser, prefix):
        self._d = data
        self._p = prefix
        self._parser = parser

    def extra_depends(self):
        return []

    @property
    def name(self):
        return self._d['name']

    @property
    def depends(self):
        return uniq_list(self._d.get('depends', []) + self.extra_depends())

    @property
    def inc_dirs(self):
        return uniq_list(self.global_inc_dirs() + self._d.get('inc_dirs', []))

    @cached_method
    def global_inc_dirs(self):
        def iter_dirs():
            yield from self._d.get('global_inc_dirs', [])

            for sm in self.iter_sub_modules(self.depends):
                yield from sm.global_inc_dirs()

        res = uniq_list(iter_dirs())

        print(self.prefix, self.depends, res)

        return res

    @property
    def c_flags(self):
        return self._d.get('c_flags', []) + self._d.get('c_only_flags', [])

    @property
    def cxx_flags(self):
        return self._d.get('c_flags', []) + self._d.get('cxx_flags', [])

    @property
    def ld_flags(self):
        return self._d.get('ld_flags', [])

    @property
    def parser(self):
        return self._parser

    @property
    def prefix(self):
        return self._p

    @property
    def srcs(self):
        return [('$(S)/' + self.prefix + '/' + x) for x in self._d.get('srcs', [])]

    @property
    def join_srcs(self):
        return [('$(S)/' + self.prefix + '/' + x) for x in self._d.get('join_srcs', [])]

    @property
    def compiler(self):
        return self.parser.compiler

    def src_path(self, p):
        return os.path.normpath(self.parser.replace_path(p))

    def parse_includes(self, pp):
        v = set()

        def do(p):
            if p in v:
                return

            v.add(p)

            p = self.find_location(p)

            yield p

            if from_sd(p):
                for i in self.parser.inc_parser.parse_cpp_includes(self.src_path(p)):
                    yield from do('$(S)/' + i[1:-1])

        yield from do(pp)

    def find_location(self, p):
        def it():
            yield from self.iter_inc_dirs()
            yield '$(S)/' + self.prefix

        for x in it():
            pp = p.replace('$(S)', x)
            spp = self.src_path(pp)

            if os.path.exists(spp):
                return pp

        return to_bd(p)

    def iter_inc_dirs(self):
        yield '$(S)'

        for x in self.inc_dirs:
            yield '$(S)/' + x

    def parse_includes_md5(self, p):
        def it():
            for i in self.parse_includes(p):
                if from_bd(i):
                    yield {
                        'path': i,
                    }
                else:
                    with open(self.src_path(i)) as f:
                        yield {
                            'path': i,
                            'md5': struct_hash(f.read()),
                        }

        return list(it())

    def build_command_1(self, src):
        by_ext = {
            'C': self.cxx_compile_command,
            'cc': self.cxx_compile_command,
            'cxx': self.cxx_compile_command,
            'cpp': self.cxx_compile_command,
            'c': self.c_compile_command,
            'S': self.c_compile_command,
            's': self.c_compile_command,
            'file2c': self.file2c_command,
        }

        def nope(src):
            return []

        return by_ext.get(fext(src), nope)(src)

    def build_command_0(self, src):
        to_v = [src]
        v = set()

        while to_v:
            s = to_v.pop()

            if s in v:
                continue

            v.add(s)

            for c in self.build_command_1(s):
                yield c

                for o in c['out']:
                    to_v.append(o)

    def build_command(self, src):
        return list(self.build_command_0(src))

    def join_srcs_command(self, srcs):
        o = '$(B)/' + self.prefix + '/' + struct_hash('_'.join(srcs)) + '.' + fext(srcs[0])

        def iter_inc():
            for s in srcs:
                yield from self.parse_includes_md5(s)

        return {
            'in': srcs,
            'out': [o],
            'cmd': [
                ['/bin/sh', '-c', 'cat ' + ' '.join(srcs) + ' > ' + o],
            ],
            'inc': list(iter_inc()),
        }

    def file2c_command(self, src):
        o = to_bd(strip_ext(src) + '.h')

        return [
            {
                'in': [src, '$(B)/third_party/tools/file2c/file2c'],
                'out': [o],
                'cmd': [
                    ['/bin/sh', '-c', '$(B)/third_party/tools/file2c/file2c < ' + src + ' > ' + o],
                ],
                'depends': ['third_party/tools/file2c'],
                'inc': self.parse_includes_md5(src),
            },
        ]

    def c_compile_command(self, src):
        o = to_bd(src + '.o')

        return [
            {
                'in': [src],
                'out': [o],
                'cmd': self.compiler.c_compile_command(src, o, list(self.iter_inc_dirs()) + ['$(B)'], self.c_flags),
                'inc': self.parse_includes_md5(src),
            },
        ]

    def cxx_compile_command(self, src):
        o = to_bd(src + '.o')

        return [
            {
                'in': [src],
                'out': [o],
                'cmd': self.compiler.cxx_compile_command(src, o, list(self.iter_inc_dirs()) + ['$(B)'], self.cxx_flags),
                'inc': self.parse_includes_md5(src),
            },
        ]

    def link_command(self, srcs, out):
        o = '$(B)/' + self.prefix + '/' + out

        return {
            'in': srcs,
            'out': [o],
            'cmd': self.compiler.link_command(srcs, o, self.ld_flags) + [
                ['ln', '-f', o, to_sd(o)],
            ],
        }

    def ar_command(self, srcs, out):
        o = '$(B)/' + self.prefix + '/' + out

        return {
            'in': srcs,
            'out': [o],
            'cmd': self.compiler.ar_command(srcs, o),
        }

    def iter_simple_commands(self):
        for s in self.srcs:
            yield from self.build_command(s)

        js = self.join_srcs

        if js:
            cmd = self.join_srcs_command(js)

            yield cmd

            for o in cmd['out']:
                yield from self.build_command(o)

    def iter_sub_modules(self, deps):
        for d in deps:
            yield self.parser.parse_module(d)

    def calc_commands(self):
        # compile
        cc = list(self.iter_simple_commands())

        def iter_ss():
            for l in cc:
                for o in l['out']:
                    if o.endswith('.o'):
                        yield o

        ss = list(iter_ss())

        def iter_depends():
            yield from self.depends

            for l in cc:
                yield from l.get('depends', [])

        # libs
        dc = sum([d.commands() for d in self.iter_sub_modules(iter_depends())], [])

        return cc, ss, dc


class SystemCompiler(object):
    def compile_command(self, cxx, src, out, inc, flags):
        return [
            cxx + ['-I' + x for x in inc] + flags + ['-c', '-o', out, src],
        ]

    def c_compile_command(self, src, out, inc, flags):
        return self.compile_command(['clang'], src, out, inc, flags)

    def cxx_compile_command(self, src, out, inc, flags):
        return self.compile_command(['clang++'], src, out, inc, ['-std=c++17', '-nostdinc++'] + flags)

    def link_command(self, srcs, out, flags):
        return [['clang++', '-nostdlib++', '-o', out] + flags + srcs]

    def ar_command(self, srcs, out):
        return [['ar', 'q', out] + srcs]


class Program(Module):
    def __init__(self, data, parser, prefix):
        Module.__init__(self, data, parser, prefix)

    @cached_method
    def commands(self):
        cc, ss, dc = self.calc_commands()

        def iter_ls():
            for l in dc:
                for o in l['out']:
                    if o.endswith('.a'):
                        yield o

        ls = list(iter_ls())

        return cc + dc + [self.link_command(ss + ls, self.name)]

    def extra_depends(self):
        return ['third_party/libs/libcxx']


class Library(Module):
    def __init__(self, data, parser, prefix):
        Module.__init__(self, data, parser, prefix)

    @cached_method
    def commands(self):
        cc, ss, dc = self.calc_commands()

        return cc + dc + [self.ar_command(ss, 'lib' + self.name + '.a')]


class Recurse(Module):
    def __init__(self, data, parser, prefix):
        Module.__init__(self, data, parser, prefix)

    @property
    def recurse(self):
        return self._d['recurse']

    @property
    def depends(self):
        def iter_deps():
            for d in self.recurse:
                yield self.prefix + '/' + d

        return list(iter_deps())

    @cached_method
    def commands(self):
        return sum([d.commands() for d in self.iter_sub_modules(self.depends)], [])


class Parser(object):
    def __init__(self, root, compiler):
        self._r = root
        self._c = compiler
        self._i = IncParser()

    @property
    def inc_parser(self):
        return self._i

    @property
    def compiler(self):
        return self._c

    @property
    def root(self):
        return self._r

    def replace_path(self, p):
        return p.replace('$(S)', self.root)

    @cached_method
    def parse_module(self, target):
        msg('T', 'bc', '$(S)/' + target)

        with open(os.path.join(self.root, target, 'z.make'), 'r') as f:
            d = yaml.load(f.read(), Loader=yaml.Loader)

        if 'recurse' in d:
            return Recurse(d, self, target)

        m = d['module']

        if m == 'recurse':
            return Recurse(d, self, target)

        if m == 'program':
            if 'name' not in d:
                d['name'] = os.path.basename(target)

            return Program(d, self, target)

        if m == 'library':
            if 'name' not in d:
                d['name'] = target.replace('/libs/', '').replace('/', '_').replace('-', '_').replace('_', '').replace('lib', '')

            return Library(d, self, target)

        raise Exception('unsupported module ' + m)


def from_bd(i):
    return i[2] == 'B'


def from_sd(i):
    return i[2] == 'S'


def struct_hash(s):
    return hashlib.md5(json.dumps(s, sort_keys=True).encode('utf-8')).hexdigest()[:10]


def build_uids(g):
    by_out = {}

    for n in g:
        for o in n['out']:
            by_out[o] = n

    def uid(n):
        if 'uid' not in n:
            deps = []

            def iter_in():
                for i in n['in']:
                    if from_bd(i):
                        yield i

                for f in n.get('inc', []):
                    if 'md5' not in f:
                        yield f['path']

            for i in iter_in():
                if i in by_out:
                    deps.append(uid(by_out[i]))
                else:
                    msg('U', 'br', i)


            n['deps'] = deps
            n['uid'] = struct_hash(n)

        return n['uid']

    by_uid = {}
    res = []

    for n in g:
        u = uid(n)

        if u not in by_uid:
            by_uid[u] = n
            res.append(n)

    return res


def prepare_dir(ro):
    try:
        os.makedirs(os.path.dirname(ro))
    except OSError:
        pass


class SimpleBuilder(object):
    def __init__(self, g, parser, build_dir):
        self._g = g
        self._p = parser
        self._bd = build_dir
        self._bu = {}

        for n in self._g:
            self._bu[n['uid']] = n

    def visit(self):
        v = set()

        def visit(n):
            u = n['uid']

            if u not in v:
                v.add(u)

                for d in n['deps']:
                    yield from visit(self._bu[d])

                yield n

        for n in self._g:
            yield from visit(n)

    def replace_path(self, p, n, w):
        bp = p.replace('$(B)', self._bd + '/$(W)/' + n['uid'][:2] + '/' + n['uid'][2:]).replace('$(W)', w)

        return self._p.replace_path(bp)

    def build(self):
        for n in self.visit():
            self.build_command(n)

    def build_command(self, n):
        where_c = self.replace_path('$(B)', n, 'c')
        where_t = self.replace_path('$(B)', n, 't')

        if os.path.exists(where_c):
            msg('C', 'bb', n['uid'])

            return

        shutil.rmtree(where_t, ignore_errors=True)

        for o in n['out']:
            prepare_dir(self.replace_path(o, n, 't'))

        for d in n['deps']:
            dn = self._bu[d]

            shutil.copytree(self.replace_path('$(B)', dn, 'c'), where_t, dirs_exist_ok=True)

        for c in n['cmd']:
            msg('B', 'bg', ' '.join(c))
            subprocess.check_call([self.replace_path(x, n, 't') for x in c], shell=False)

        shutil.move(where_t, where_c)


def main(args):
    p = Parser(find_root(), SystemCompiler())
    t = strip_prefix(get_target(args.target), p.root)
    m = p.parse_module(t)
    g = build_uids(m.commands())

    if args.verbose:
        print(json.dumps(g, indent=4, sort_keys=True))

    build_dir = os.path.join(os.path.expanduser('~'), '.zbuild')

    if args.clear:
        shutil.rmtree(build_dir)

    SimpleBuilder(g, p, build_dir).build()


if __name__ == '__main__':
    argp = argparse.ArgumentParser()

    argp.add_argument('target', nargs='?', default='.')
    argp.add_argument('-v', '--verbose', help='verbose mode', default=False, action='store_const', const=True)
    argp.add_argument('--clear', help='clear cache', default=False, action='store_const', const=True)

    args = argp.parse_args(sys.argv[1:])

    if args.verbose:
        main(args)
    else:
        try:
            main(args)
        except Exception as e:
            print(e)
