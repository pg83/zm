#!/usr/bin/env python3

import os
import sys
import json
import yaml
import hashlib
import argparse
import subprocess
import shutil


## colors

ATTRIBUTES = dict(
    list(zip(
        [
            'bold',
            'dark',
            '',
            'underline',
            'blink',
            '',
            'reverse',
            'concealed'
        ], list(range(1, 9)))))

del ATTRIBUTES['']

ATTRIBUTES['light'] = ATTRIBUTES['bold']

HIGHLIGHTS = dict(
    list(zip([
        'on_grey',
        'on_red',
        'on_green',
        'on_yellow',
        'on_blue',
        'on_magenta',
        'on_cyan',
        'on_white'
    ], list(range(40, 48)))))

COLORS = dict(
    list(zip([
        'steel',
        'red',
        'green',
        'yellow',
        'blue',
        'magenta',
        'cyan',
        'white',
    ], list(range(30, 38)))))

COLORS['reset'] = 0


def get_code(code):
    return "\033[{}m".format(code)


def get_color_0(color, on_color):
    res = ''

    if color is not None:
        res += get_code(COLORS[color])

    if on_color is not None:
        res += get_code(HIGHLIGHTS[on_color])

    return res


def color_key(color, on_color):
    return str(color) + '-' + str(on_color)


def iter_all_colors():
    for c in list(COLORS.keys()) + [None]:
        for o in list(HIGHLIGHTS.keys()) + [None]:
            yield color_key(c, o), get_color_0(c, o)


CC = dict(iter_all_colors())


def get_color_ext(color, on_color=None, attrs=[]):
    res = CC[color_key(color, on_color)]

    for attr in attrs:
        res += get_code(ATTRIBUTES[attr])

    return res


def iter_synonyms():
    for c in COLORS:
        if c == 'reset':
            continue

        yield c[0], c
        yield c, c


def iter_combo():
    attrs = [[], ['bold'], ['dark'], ['bold', 'dark']]

    for s, c in iter_synonyms():
        for a in attrs:
            if len(s) == 1:
                aa = [x[0] for x in a]
            else:
                aa = a

            name = ''.join(aa + [s])
            b = [x for x in a]

            yield name, c, b
            yield '{' + name + '}', c, b


def iter_full_table():
    for n, c, a in iter_combo():
        yield n, get_color_ext(c, on_color=None, attrs=a)

    for r in ('', 'rst', 'reset'):
        yield r, get_code(0)
        yield '{' + r + '}', get_code(0)


COLOR_TABLE = dict(iter_full_table())


def get_color(n):
    return COLOR_TABLE[n]


def colorize(text, color):
    return get_color(color) + text + get_color('')


def msg(l, c, msg):
    m = colorize('[' + l + '] ', c) + msg.replace('$(S)', colorize('$(S)', 'bg')).replace('$(B)', colorize('$(B)', 'by'))

    print(m)

## end color

def singleton(f):
    def wrapper():
        try:
            wrapper.__res__
        except AttributeError:
            wrapper.__res__ = f()

        return wrapper.__res__

    return wrapper


def cached_method(meth):
    def wrapper(self, *args, **kwargs):
        try:
            self.__cache__
        except Exception:
            self.__cache__ = {}

        d = self.__cache__
        k = struct_hash([args, kwargs, meth.__name__])

        if k not in d:
            d[k] = meth(self, *args, **kwargs)

        return d[k]

    return wrapper


@singleton
def find_root():
    res = os.path.dirname(os.path.normpath(os.path.abspath(__file__)))

    msg('R', 'by', res)

    return res


def get_target(t):
    path = os.path.join(os.getcwd(), t)

    return os.path.normpath(os.path.abspath(path))


def strip_prefix(s, p):
    assert s.startswith(p), 'out of root build'

    return s[len(p) + 1:]


cpp_excludes = {
    '$(B)/stdio.h',
    '$(B)/stdlib.h',
    '$(B)/string.h',
    '$(B)/iostream',
    '$(B)/Availability.h',
    '$(B)/AvailabilityMacros.h',
    '$(B)/System/pthread_machdep.h',
    '$(B)/assert.h',
    '$(B)/dlfcn.h',
    '$(B)/excpt.h',
    '$(B)/inttypes.h',
    '$(B)/link.h',
    '$(B)/mach-o/dyld.h',
    '$(B)/mach-o/getsect.h',
    '$(B)/ntstatus.h',
    '$(B)/ntverp.h',
    '$(B)/psapi.h',
    '$(B)/pthread.h',
    '$(B)/stdbool.h',
    '$(B)/stddef.h',
    '$(B)/stdint.h',
    '$(B)/stdio.h',
    '$(B)/stdlib.h',
    '$(B)/string.h',
    '$(B)/sys/mman.h',
    '$(B)/windef.h',
    '$(B)/windows.h',
    '$(B)/winnt.h',
}


def parse_cpp_includes(p):
    msg('P', 'bm' ,p)

    with open(p, 'r') as f:
        data = f.read()

    for l in data.splitlines():
        l = l.strip()

        if not l:
            continue

        if l[0] != '#':
            continue

        if 'include' not in l:
            continue

        p1 = l.find('<')

        if p1 > 0:
            l = l[p1 + 1:]

            yield '<' + l[:l.find('>')] + '>'
        else:
            p1 = l.find('"')
            l = l[p1 + 1:]

            yield '"' + l[:l.find('"')] + '"'


class IncParser(object):
    def __init__(self):
        self._c = {}

    def parse_cpp_includes(self, p):
        if p not in self._c:
            self._c[p] = list(parse_cpp_includes(p))

        return self._c[p]


def to_bd(p):
    return p.replace('$(S)', '$(B)')


def to_sd(p):
    return p.replace('$(B)', '$(S)')


def fext(p):
    return os.path.basename(p).split('.')[-1]


def strip_ext(p):
    return p[:-1 - len(fext(p))]


class Module(object):
    def __init__(self, data, parser, prefix):
        self._d = data
        self._p = prefix
        self._s = [('$(S)/' + self.prefix + '/' + x) for x in data.get('srcs', [])]
        self._parser = parser

    @property
    def name(self):
        return self._d['name']

    @property
    def depends(self):
        return self._d.get('depends', [])

    @property
    def inc_dirs(self):
        return self._d.get('inc_dirs', [])

    @property
    def parser(self):
        return self._parser

    @property
    def prefix(self):
        return self._p

    @property
    def srcs(self):
        return self._s

    @property
    def compiler(self):
        return self.parser.compiler

    def src_path(self, p):
        return self.parser.replace_path(p)

    def parse_includes(self, pp):
        v = set()

        def do(p):
            if p in v:
                return

            v.add(p)

            p = self.find_location(p)

            yield p

            if from_sd(p):
                for i in self.parser.inc_parser.parse_cpp_includes(self.src_path(p)):
                    if i[0] == '<':
                        yield from do('$(S)/' + i[1:-1])
                    else:
                        yield from do(os.path.dirname(p) + '/' + i[1:-1])
            else:
                msg('U', 'br', p)

        yield from do(pp)

    def find_location(self, p):
        for x in self.iter_inc_dirs():
            pp = p.replace('$(S)', x)
            spp = self.src_path(pp)

            if os.path.exists(spp):
                return pp

        return to_bd(p)

    def iter_inc_dirs(self):
        yield '$(S)'

        for x in self.inc_dirs:
            yield '$(S)/' + x

    def parse_includes_md5(self, p):
        def it():
            for i in self.parse_includes(p):
                if from_bd(i):
                    yield {
                        'path': i,
                    }
                else:
                    with open(self.src_path(i)) as f:
                        yield {
                            'path': i,
                            'md5': struct_hash(f.read()),
                        }

        return list(it())

    def build_command_1(self, src):
        by_ext = {
            'C': self.cxx_compile_command,
            'cc': self.cxx_compile_command,
            'cxx': self.cxx_compile_command,
            'cpp': self.cxx_compile_command,
            'c': self.c_compile_command,
            'S': self.c_compile_command,
            's': self.c_compile_command,
            'file2c': self.file2c_command,
        }

        def nope(src):
            return []

        return by_ext.get(fext(src), nope)(src)

    def build_command(self, src):
        to_v = [src]
        v = set()
        res = []

        while to_v:
            s = to_v.pop()

            if s in v:
                continue

            v.add(s)

            for c in self.build_command_1(s):
                res.append(c)

                for o in c['out']:
                    to_v.append(o)

        return res

    def file2c_command(self, src):
        o = to_bd(strip_ext(src) + '.h')

        return [
            {
                'in': [src, '$(B)/third_party/tools/file2c/file2c'],
                'out': [o],
                'cmd': [
                    ['/bin/sh', '-c', '$(B)/third_party/tools/file2c/file2c < ' + src + ' > ' + o],
                ],
                'depends': ['third_party/tools/file2c'],
                'inc': self.parse_includes_md5(src),
            },
        ]

    def c_compile_command(self, src):
        o = to_bd(src + '.o')

        return [
            {
                'in': [src],
                'out': [o],
                'cmd': self.compiler.c_compile_command(src, o, list(self.iter_inc_dirs()) + ['$(B)']),
                'inc': self.parse_includes_md5(src),
            },
        ]

    def cxx_compile_command(self, src):
        o = to_bd(src + '.o')

        return [
            {
                'in': [src],
                'out': [o],
                'cmd': self.compiler.cxx_compile_command(src, o, list(self.iter_inc_dirs()) + ['$(B)']),
                'inc': self.parse_includes_md5(src),
            },
        ]

    def link_command(self, srcs, out):
        o = '$(B)/' + self.prefix + '/' + out

        return {
            'in': srcs,
            'out': [o],
            'cmd': self.compiler.link_command(srcs, o) + [
                ['ln', '-fs', o, to_sd(o)],
            ],
        }

    def ar_command(self, srcs, out):
        o = '$(B)/' + self.prefix + '/' + out

        return {
            'in': srcs,
            'out': [o],
            'cmd': self.compiler.ar_command(srcs, o),
        }

    def calc_commands(self):
        # compile
        cc = sum([self.build_command(s) for s in self.srcs], [])

        def iter_ss():
            for l in cc:
                for o in l['out']:
                    if o.endswith('.o'):
                        yield o

        ss = list(iter_ss())

        def iter_depends():
            yield from self.depends

            for l in cc:
                yield from l.get('depends', [])

        # libs
        dc = sum([self.parser.parse_module(d).commands() for d in iter_depends()], [])

        return cc, ss, dc


class SystemCompiler(object):
    def c_compile_command(self, src, out, inc):
        return [
            ['clang'] + ['-I' + x for x in inc] + ['-c', '-o', out, src],
        ]

    def cxx_compile_command(self, src, out, inc):
        return [
            ['clang++', '-std=c++17'] + ['-I' + x for x in inc] + ['-c', '-o', out, src],
        ]

    def link_command(self, srcs, out):
        return [['clang++', '-o', out] + srcs]

    def ar_command(self, srcs, out):
        return [['ar', 'q', out] + srcs]


class Program(Module):
    def __init__(self, data, parser, prefix):
        Module.__init__(self, data, parser, prefix)

    @cached_method
    def commands(self):
        cc, ss, dc = self.calc_commands()

        def iter_ls():
            for l in dc:
                for o in l['out']:
                    if o.endswith('.a'):
                        yield o

        ls = list(iter_ls())

        return cc + dc + [self.link_command(ss + ls, self.name)]


class Library(Module):
    def __init__(self, data, parser, prefix):
        Module.__init__(self, data, parser, prefix)

    @cached_method
    def commands(self):
        cc, ss, dc = self.calc_commands()

        return cc + dc + [self.ar_command(ss, 'lib' + self.name + '.a')]


class Recurse(object):
    def __init__(self, data, parser, prefix):
        self._d = data['recurse']
        self._parser = parser
        self._prefix = prefix

    @cached_method
    def commands(self):
        return sum([self._parser.parse_module(os.path.join(self._prefix, d)).commands() for d in self._d], [])


class Parser(object):
    def __init__(self, root, compiler):
        self._r = root
        self._p = {}
        self._c = compiler
        self._i = IncParser()

    @property
    def inc_parser(self):
        return self._i

    @property
    def compiler(self):
        return self._c

    @property
    def root(self):
        return self._r

    def replace_path(self, p):
        return p.replace('$(S)', self.root)

    def do_parse_module(self, target):
        msg('T', 'bc', '$(S)/' + target)

        with open(os.path.join(self.root, target, 'z.make'), 'r') as f:
            d = yaml.load(f.read(), Loader=yaml.Loader)

        if 'recurse' in d:
            return Recurse(d, self, target)

        m = d['module']

        if m == 'recurse':
            return Recurse(d, self, target)

        if 'name' not in d:
            d['name'] = os.path.basename(target)

        if m == 'program':
            return Program(d, self, target)

        if m == 'library':
            return Library(d, self, target)

        raise Exception('unsupported module ' + m)

    def parse_module(self, target):
        if target not in self._p:
            self._p[target] = self.do_parse_module(target)

        return self._p[target]


def from_bd(i):
    return i[2] == 'B'


def from_sd(i):
    return i[2] == 'S'


def struct_hash(s):
    return hashlib.md5(json.dumps(s, sort_keys=True).encode('utf-8')).hexdigest()[:10]


def build_uids(g):
    by_out = {}

    for n in g:
        for o in n['out']:
            by_out[o] = n

    def uid(n):
        if 'uid' not in n:
            deps = []

            def iter_in():
                for i in n['in']:
                    if from_bd(i):
                        yield i

                for f in n.get('inc', []):
                    if 'md5' not in f:
                        yield f['path']

            for i in iter_in():
                if i in by_out:
                    deps.append(uid(by_out[i]))
                else:
                    if i in cpp_excludes:
                        pass
                    else:
                        raise Exception('no build file ' + i)

            n['deps'] = deps
            n['uid'] = struct_hash(n)

        return n['uid']

    by_uid = {}
    res = []

    for n in g:
        u = uid(n)

        if u not in by_uid:
            by_uid[u] = n
            res.append(n)

    return res


def prepare_dir(ro):
    try:
        os.makedirs(os.path.dirname(ro))
    except OSError:
        try:
            os.unlink(ro)
        except FileNotFoundError:
            pass


class SimpleBuilder(object):
    def __init__(self, g, parser, build_dir):
        self._g = g
        self._p = parser
        self._bd = build_dir
        self._bu = {}

        for n in self._g:
            self._bu[n['uid']] = n

    def visit(self):
        v = set()

        def visit(n):
            u = n['uid']

            if u not in v:
                v.add(u)

                for d in n['deps']:
                    yield from visit(self._bu[d])

                yield n

        for n in self._g:
            yield from visit(n)

    def replace_path(self, p, n):
        bp = p.replace('$(B)', self._bd + '/' + n['uid'][:2] + '/' + n['uid'][2:])

        return self._p.replace_path(bp)

    def build(self):
        for n in self.visit():
            where = self.replace_path('$(B)', n)

            if os.path.exists(where):
                msg('C', 'bb', n['uid'])

                continue

            for o in n['out']:
                prepare_dir(self.replace_path(o, n))

            for d in n['deps']:
                dn = self._bu[d]

                shutil.copytree(self.replace_path('$(B)', dn), where, dirs_exist_ok=True)

            for c in n['cmd']:
                msg('B', 'bg', ' '.join(c))

                try:
                    subprocess.check_call([self.replace_path(x, n) for x in c], shell=False)
                except:
                    shutil.rmtree(where)

                    raise


def main(args):
    p = Parser(find_root(), SystemCompiler())
    t = strip_prefix(get_target(args.target), p.root)
    m = p.parse_module(t)
    g = build_uids(m.commands())

    if args.verbose:
        print(json.dumps(g, indent=4, sort_keys=True))

    build_dir = os.path.join(os.path.expanduser('~'), '.zbuild')

    if args.clear:
        shutil.rmtree(build_dir)

    SimpleBuilder(g, p, build_dir).build()


if __name__ == '__main__':
    argp = argparse.ArgumentParser()

    argp.add_argument('target', nargs='?', default='.')
    argp.add_argument('-v', '--verbose', help='verbose mode', default=False, action='store_const', const=True)
    argp.add_argument('--clear', help='clear cache', default=False, action='store_const', const=True)

    args = argp.parse_args(sys.argv[1:])

    if args.verbose:
        main(args)
    else:
        try:
            main(args)
        except Exception as e:
            print(e)
